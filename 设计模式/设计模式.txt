创建型模式:
    单例模式、工厂模式、抽象工厂模式、建造者模式、原型模式。
结构型模式：
    适配器模式、桥接模式、装饰模式、组合模式、外观模式、享元模式、代理模式。
行为型模式：
    模版方法模式、命令模式、迭代器模式、观察者模式、中介者模式、备忘录模式、
    解释器模式、状态模式、策略模式、职责链模式、访问者模式


单例模式
    windows的任务管理器、回收站
    读取配置文件的类、网站计数器、应用程序的日志应用
    数据库连接池的设计、每个servlet也是单例
    Spring中的application对象单例、每个Bean也是单例(action是多例)、控制器对象也是单例

    饿汉式：
        static实例随类加载而加载，类加载器加载时线程安全，不需要在获取实例的方法上再加同步 
        优缺点：线程安全，不加锁并发效率高，没有延迟加载，可能会造成资源浪费
    懒汉式：
        优缺点：延时加载，提高资源利用率，但因为加锁，并发效率较低
    双重检测锁：
        不在方法体上加synchronized，在第一次创建时在内部if判判断里加锁，即提高了并发效率又延时加载
        由于编译器优化和JVM底层内部模型原因，偶尔会出问题，不建议使用
    静态内部类式：
        外部类没有static属性，则不会像饿汉式那样立即加载对象
        只有真正调用getInstance()，才会加载静态内部类，加载类时是线程安全的
        兼备了并发高效调用和延迟加载的优势
    枚举式：
        可以防止反射和反序列化的漏洞
        调用效率高，唯一不足是没有懒加载

    总结
        饿汉式(线程安全，调用效率高，不能延时加载)
        懒汉式(线程安全，调用效率不高，可以延时加载)
        双重检测锁式(由于JVM底层内部模型原因，偶尔会出问题，不建议使用)
        静态内部类式(线程安全，调用效率不高，可以延时加载)
        枚举式(线程安全，调用效率高，不能延时加载，天然防止反射和序列化漏洞)
        
        反射和反序列化漏洞
            反射漏洞：获取字节码文件后可以跳过私有构造器的安全检查
            反射漏洞解决：在构造方法中进行实例是否存在判断，不存在则创建，存在则抛出运行时异常
                private  静态内部类实现单例(){
                    if(InnerClass.instance!=null){
                        throw  new RuntimeException("已经存在实例");
                    }
                }
            反序列化漏洞：对象在序列化传输之后，进行反序列化，则重新返回一个新的对象
            反序列化漏洞解决：在类中定义readResolve()则直接返回此方法指定的对象，而不单独重新创建
                private Object readResolve() throws ObjectStreamException{
                    return instance;
                }
    
    如何选用？
        单例对象 占用 资源少，不需要 延时加载：
            枚举式 好于 饿汉式
        单例对象 占用 资源大， 需要 延时加载：
            静态内部类式 好于 懒汉式

工厂模式
    不使用设计模式:
        Car byd = new BYD();
        Car bmw = new BWM();
        如果想要获取一辆车的话,通过自己建造(也就是new的方式)需要知道Car接口,还需要知道具体的构造图纸(BYD构造函数),可能还
        需要向构造方法传入很多的参数,如果想换宝马了,则还需要相同的步骤,每次都需要详细的知道制造一辆车的具体参数和图纸,这
        在现实中根本行不通,你想要拥有一辆车,肯定是去工厂直接提一辆最便宜,而你去提车,只需要知道告诉工厂你要什么车就可以了.

    静态工厂/简单工厂模式:
        Car bwm=CarFactory.createCar("宝马");
        Car byd=CarFactory.createCar("比亚迪");
        CarFactory就是你去要提车的工厂,告诉他你想要什么车就可以了,然后让他自己去找图纸,去传入默认参数,等他建造完成后将车
        返回给你,你只需要知道Car接口和你想要的车型.
        该模式不满足OCP原则 对扩展开放,对修改关闭.
        如果该工厂没有你要的车型,则只能对工厂类进行代码上的修改,不支持动态扩展

    工厂方法模式:
        为了避免简单工厂模式的缺点,不完全满足(OCP)open close principle(喷森抛)
        工厂方法模式和简单工厂模式最大的不同在于,简单工厂模式只有一个(对于一个项目或者一个独立模块而言)工厂类
        而工厂方法模式有一组实现了相同接口的工厂类.


代理模式
    核心作用:
        可以详细控制某个（某类）对象的方法，在调用这个方法前做前置处理，调用这个方法后做后置处理（AOP的核心机制）
        可以参考JavaWeb中的过滤器，将核心代码前后的重复代码从核心类中抽离，单独放置成为一个代理类，由该代理类来控制具体
        的方法调用时机。
    核心角色:
        抽象角色
            定义代理角色和真实角色的公共对外方法
        真实角色
            实现抽象角色，定义真实角色所要实现的业务逻辑，供代理角色调用，只需要做好真正的业务逻辑
        代理角色
            实现抽象角色，是真实角色的代理，通过调用真实角色的业务方法并在调用前后进行自己的操作来实现对外公共方法
            将统一的流程控制放到代理角色中处理。

    分类：
        静态代理(静态生成代理类)
        动态代理(动态生成代理类)
            JDK自带的动态代理
                java.lang.reflect.Proxy
                作用：动态生成代理类和对象
                java.lang.reflect.InvocationHandler(处理器接口)
                可以通过invoke方法实现对真实角色的代理访问
                每次通过Proxy生成代理类对象时都要指定对应的处理器对象
                简述：通过Proxy.newProxyInstance()生成一个继承Proxy 实现目标接口的代理对象
                          1.生成代理类的源代码
                          2.将生成的源代码输出到磁盘，保存为.java文件
                          3.编译源代码，并且生成.class文件
                          4.将class文件动态加载到JVM中
                          5.使用反射返回代理对象
                      调用代理对象的目标接口方法时，执行 this.h.invoke(this, m6, null);
                      null 表示没有参数
                      m6 表示被调用method的对象，该对象由具体的代理对象保存 6则是该方法的编号
                      其中的h为其父类Proxy中成员变量 protected InvocationHandler h 也就是之前传入的StarHandler
                      在StarHandler中则进行对需要代理方法的附加操作

            CGLIB代理
                引入cglib-jdr包后，就可以在内存中动态构建子类
                代理的类不能为final，否则报错 在内存中构建子类来做扩展，当然不能为final，有final就不能继承了
                目标对象的方法如果为final/static, 那么就不会执行目标对象额外的业务方法。
                因为没有实现接口该类无法使用JDK代理，通过CGLIB代理实现如下：

                首先实现一个MethodInterceptor，方法调用会被转发到该类的intercept()方法。
                然后在需要使用HelloConcrete的时候，通过CGLIB动态代理获取代理对象。
                通过CGLIB的Enhancer来指定要代理的目标对象、实际处理代理逻辑的对象，通过调用create()方法得到代理对象
                对这个对象所有非final方法的调用都会转发给MethodInterceptor.intercept()方法，
                在intercept()方法里我们可以加入任何逻辑，比如修改方法参数，加入日志功能、安全检查功能等；
                通过调用MethodProxy.invokeSuper()方法，将调用转发给原始对象，就是HelloConcrete的具体方法。
                CGLIG中MethodInterceptor的作用跟JDK代理中的InvocationHandler很类似，都是方法调用的中转站。

                使用CGLIB代理之后的对象类型是cglib.HelloConcrete$$EnhancerByCGLIB$$e3734e52，这是CGLIB动态生成的类型；
                父类是HelloConcrete，印证了CGLIB是通过继承实现代理；
                同时实现了net.sf.cglib.proxy.Factory接口，这个接口是CGLIB自己加入的，包含一些工具方法。

                注意，既然是继承就不得不考虑final的问题。我们知道final类型不能有子类，所以CGLIB不能代理final类型，
                遇到这种情况会抛出类似如下异常：
                java.lang.IllegalArgumentException: Cannot subclass final class cglib.HelloConcrete
                同样的，final方法是不能重载的，所以也不能通过CGLIB代理，遇到这种情况不会抛异常，而是会跳过final方法只代理其他方法。

                参考链接：
                    https://www.cnblogs.com/CarpenterLee/p/8241042.html

            javaassist 字节码操作库实现
            ASM(底层使用指令，可维护性较差)

        动态代理相比于静态代理的优点
            抽象角色中(接口)声明的所有方法都被转移到调用处理器一个集中的方法中处理，这样，我们可以更加灵活和统一的处理众
            多的方法。

    应用场景：
        安全代理：屏蔽对真实角色的直接访问
        远程代理：通过代理类处理远程方法调用(RMI)
        延迟加载：先加载轻量级的代理对象，真正需要再加载真实对象。(例如查看图片时的缩略图)
        struts2中拦截器的实现
        数据库连接池关闭处理
        Hibernate中延时加载的实现
        mybatis中实现拦截器插件
        Aspect的实现
        spring中AOP的实现
            日志拦截
            声明式事务处理
        web service
        RMI远程方法调用
