## 基本数据类型

基本类型的表示范围：

![image-20200309095445616](img/image-20200309095445616.png)

比特/位（bit）：二进制位，要么为0，要么为1 。

字节（byte）：由8个bit位 构成。

boolean 类型所占存储空间的大小没有明确指定，仅定义为能够取字面值true或false，在内存中占用1位  所以位运算符才可以操作boolean型。

Java 中每个 字符的 尺寸都是 16位（2个字节），以此来提供对Unicode字符集的支持，默认值为 `\u0000(null)`

如果按二进制来看的话，8位(bits) 最多表示255个数，而表示数值的基本类型都有正负之分，Java是将最高位作为符号位来表示，一个数的正负，最高位为0则是正数，1则是负数。这也就是为什么byte类型 表示正数的最大值是+127，分别代表1（128）1（64）1（32）1（16）1（8）1（4）1（2）1（1）。`0（0000，0000） ` 是` +0` 来表示0 ，`128（1000，0000）`也就是`-0` 来表示 -128，`129（1000，0001）` 表示 -127。

Java 提供了两个用于高精度计算的类：BigInteger 和 BigDecimal，对应整形和实型，通过调用这两个类的方法来替代操作符。

> 引用数据类型:   4个字节 用来代表对象的地址

### 数值的表示

```java
int a = 0b11;	//二进制	表示3
int b = 011;	//八进制	表示9
int c = 11;		//十进制	表示11
int d = 0x1f;	//十六进制	表示31
```

```java
long l = 10L;
float f = 1.1f;
double d = 1.1d;
```

Integer 和 Long 的toBinaryString()，可以将整型的数字转化为二进制的。

还要注意不同类型变量的转换，每个变量的大小和表示范围参考 基本数据类型 中的图片。

表示范围小的变量  转换=》 表示范围大的变量，可以直接转换。

```java
int i1 = 1;
long l = i1;
```

 表示范围大的变量  转换=》表示范围小的变量，需要进行强制转换。

```java
long l=1;
int i2= (int) l;
```

注意：强制转换可以会导致数据发生异常，如下例：

```java
byte b1 =(byte)127;	//0111,1111 127
byte b1 =(byte)128;	//1000,0000 -128
byte b1 =(byte)129;	//1000,0001 -127
byte b1 =(byte)255;	//1111,1111 -1
byte b1 =(byte)256;	//1，0000,0000 0
```

将int型（32位）的256转为byte型（8位），只会保留后边的8位，因此转换结果为0。

整型的数值运算后默认用 int 类型来接收，如果操作数中有long类型，则转化为long类型运算，结果也为long，实型的数值(小数)运算默认用 double 接收。

在能表示最大范围值的基础上再进行+1，就会发生溢出。

```java
byte res = (byte) ((byte) 127 + (byte) 1); //这里先用int类型来保存128，再进行转换，发生了溢出
System.out.println(res);	//-128 
```



## 操作符

### ==  与 ！=

对于引用类型来说，`== ` 比较的是两个引用是否指向同一个对象，如果想比较两个对象的实际内容是否相同，可以重写Object类的方法 `equals()`并进行比较。基本类型直接使用 `==` 和 `！=` 。

### 逻辑操作符

“与（&&）”、“或（||）”、“非（！）”，这里有一个需要注意的地方是，逻辑操作符会遇到一种 **短路** 现象，例如 “与” 操作， (表达式A) && (表达式B)，其中的表达式A可以为一个变量的引用，也可以是返回boolean类型的方法，B同理，如果 A 的结果为false，那么不用计算表达式B的结果（如果B是方法，那么这个方法都不会去执行），直接判定整个表达式结果为false。这样可以获得潜在的性能提升。

### 按位操作符

按位操作符有与（&）、或（|）、非（～）和异或（^），按位进行运算。

与运算的规则是，必须两个数同时为`1`，结果才为`1`：

```java
n = 0 & 0; // 0
n = 0 & 1; // 0
n = 1 & 0; // 0
n = 1 & 1; // 1
```

或运算的规则是，只要任意一个为`1`，结果就为`1`：

```java
n = 0 | 0; // 0
n = 0 | 1; // 1
n = 1 | 0; // 1
n = 1 | 1; // 1
```

非运算的规则是，`0`和`1`互换：

```java
n = ~(1000,0000); //0111,1111 127
```

异或运算的规则是，如果两个数不同，结果为`1`，否则为`0`：

```java
n = 0 ^ 0; // 0
n = 0 ^ 1; // 1
n = 1 ^ 0; // 1
n = 1 ^ 1; // 0
```

### 移位操作符

在计算机中，整数总是以二进制的形式表示。例如，`int`类型的整数`7`使用4字节表示的二进制如下：

```ascii
00000000 0000000 0000000 00000111
```

可以对整数进行移位运算。对整数`7`左移1位将得到整数`14`，左移两位将得到整数`28`：

```java
int n = 7;       // 00000000 00000000 00000000 00000111 = 7
int a = n << 1;  // 00000000 00000000 00000000 00001110 = 14
int b = n << 2;  // 00000000 00000000 00000000 00011100 = 28
int c = n << 28; // 01110000 00000000 00000000 00000000 = 1879048192
int d = n << 29; // 11100000 00000000 00000000 00000000 = -536870912
```

左移29位时，由于最高位变成`1`，因此结果变成了负数。

类似的，对整数28进行右移，结果如下：

```java
int n = 7;       // 00000000 00000000 00000000 00000111 = 7
int a = n >> 1;  // 00000000 00000000 00000000 00000011 = 3
int b = n >> 2;  // 00000000 00000000 00000000 00000001 = 1
int c = n >> 3;  // 00000000 00000000 00000000 00000000 = 0
```

如果对一个负数进行右移，最高位的`1`不动，结果仍然是一个负数：

```java
int n = -536870912;
int a = n >> 1;  // 11110000 00000000 00000000 00000000 = -268435456
int b = n >> 2;  // 10111000 00000000 00000000 00000000 = -134217728
int c = n >> 28; // 11111111 11111111 11111111 11111110 = -2
int d = n >> 29; // 11111111 11111111 11111111 11111111 = -1
```

还有一种不带符号的右移运算，使用`>>>`，它的特点是符号位跟着动，因此，对一个负数进行`>>>`右移，它会变成正数，原因是最高位的`1`变成了`0`：

```java
int n = -536870912;
int a = n >>> 1;  // 01110000 00000000 00000000 00000000 = 1879048192
int b = n >>> 2;  // 00111000 00000000 00000000 00000000 = 939524096
int c = n >>> 29; // 00000000 00000000 00000000 00000111 = 7
int d = n >>> 31; // 00000000 00000000 00000000 00000001 = 1
```

对`byte`和`short`类型进行移位时，会首先转换为`int`再进行位移。

仔细观察可发现，左移实际上就是不断地×2，右移实际上就是不断地÷2。

### 三目运算符

（boolean）？A：B

如果boolean为true，则执行A，否则执行B，其中，如果遇到可以转换为数字的类型，会做自动类型提升。

```java
Object o1 = (false) ? new Double(1) : new Integer(2);
System.out.println(o1);	//2.0
```



## 初始化与清理

用构造器确保初始化

重载和重写

finalize（）

## Java核心类

### Random

用来生产随机数，在创建 Random 对象时，可以传入一个`seed(种子)` ，对于特定的种子总是会生成相同的随机数列，可以调用方法 `nextInt(int bound)` 获取，结果会从 `[0,bound)` 里取，包左不包右。



## 正则表达式

正则表达式（regex）用来高效匹配，Java标准库 `java.util.regex` 包内置了正则表达式引擎。

而我们只需要一个描述一个字符串规则就可以判断目标字符串是否匹配规则。

```java
//检测是否是11位手机号
String phoneRegex = "152xxxxxxxx";
boolean res = phone.matches("\\d{11}");
```

上例中，用 ` \d` 表示一个数字，`{11}` 表示有前边类型的个数。（在Java的字符串中，反斜线`\` 表示转义字符，比如 `\r` 表示回车 `\n` 表示换行，而 `\\` 则表示一个 反斜线 `\`）。

```java
String s1 = "152\\d{8}" //表示152开头的总共11位数字
```

### 简单匹配规则

正则表达式的匹配规则是从左到右按规则匹配。

对于正则表达式`abc`来说，它只能精确地匹配字符串`"abc"`，不能匹配`"ab"`，`"Abc"`，`"abcd"`等其他任何字符串。

如果正则表达式有特殊字符，那就需要用`\`转义。例如，正则表达式`a\&c`，在Java中的用字符串表示的话是 `"a\\&c"`，其中`\&`是用来匹配特殊字符`&`的，它能精确匹配字符串`"a&c"`，但不能匹配`"ac"`、`"a-c"`、`"a&&c"`等。

如果想匹配非ASCII字符，例如中文，那就用`\u####`的十六进制表示，例如：`a\u548cc`匹配字符串`"a和c"`，中文字符`和`的Unicode编码是`548c`。很多网站对输入的关键字过滤就是通过这种方式。

**匹配任意字符**

大多数情况下我们需要模糊匹配 ，可以使用 `.`  来匹配一个任意字符。

例如，正则表达式 `a.c` 可以匹配 "abc"、”a&c”、“acc”，但是不能匹配“ac”、“abbc”。

**匹配数字**

如果我们只想匹配一个0～9的数字可以使用 `\d`。

`00\d` 可以匹配”008“、”009“，但是不能匹配 ”0010“、”00a“。

**匹配常用字符**

`\w` 可以匹配一个字母、数字或下划线，w代表word。不能匹配到 ”#“和 ” “(空格)。

### 小结

单个字符的匹配规则如下：

| 正则表达式 | 规则                     | 可以匹配                       |
| :--------- | :----------------------- | :----------------------------- |
| `A`        | 指定字符                 | `A`                            |
| `\u548c`   | 指定Unicode字符          | `和`                           |
| `.`        | 任意字符                 | `a`，`b`，`&`，`0`             |
| `\d`       | 数字0~9                  | `0`~`9`                        |
| `\w`       | 大小写字母，数字和下划线 | `a`~`z`，`A`~`Z`，`0`~`9`，`_` |
| `\s`       | 空格、Tab键              | 空格，Tab                      |
| `\D`       | 非数字                   | `a`，`A`，`&`，`_`，……         |
| `\W`       | 非\w                     | `&`，`@`，`中`，……             |
| `\S`       | 非\s                     | `a`，`A`，`&`，`_`，……         |

多个字符的匹配规则如下：

| 正则表达式 | 规则             | 可以匹配                 |
| :--------- | :--------------- | :----------------------- |
| `A*`       | 任意个数字符     | 空，`A`，`AA`，`AAA`，…… |
| `A+`       | 至少1个字符      | `A`，`AA`，`AAA`，……     |
| `A?`       | 0个或1个字符     | 空，`A`                  |
| `A{3}`     | 指定个数字符     | `AAA`                    |
| `A{2,3}`   | 指定范围个数字符 | `AA`，`AAA`              |
| `A{2,}`    | 至少n个字符      | `AA`，`AAA`，`AAAA`，……  |
| `A{0,3}`   | 最多n个字符      | 空，`A`，`AA`，`AAA`     |

### 复杂匹配规则

用正则表达式进行多行匹配时，我们用`^`表示开头，`$`表示结尾。例如，`^A\d{3}$`，可以匹配`"A001"`、`"A380"`，但是不能匹配 `"A0001"`，原因是A后边第一个0没有对应上，我们稍微修改一下就可以了，如  `^A.\\d{3}$`或者 `^A\\d{4}$` 都可以。

复杂匹配规则主要有：

| 正则表达式 | 规则                 | 可以匹配                             |
| :--------- | :------------------- | :----------------------------------- |
| ^          | 开头                 | 字符串开头                           |
| $          | 结尾                 | 字符串结束                           |
| [ABC]      | […]内任意字符        | A，B，C                              |
| [A-F0-9xy] | 指定范围的字符       | `A`，……，`F`，`0`，……，`9`，`x`，`y` |
| [^A-F]     | 指定范围外的任意字符 | 非`A`~`F`                            |
| AB\|CD\|EF | AB或CD或EF           | `AB`，`CD`，`EF`                     |

## 其他

java使用的是Unicode而不是ASCII字符集，所以标识符中的字母不仅是英文，也可以是"$" 或者 ”_“，还包括汉字（每个汉字占两个字节），但不建议使用汉字。

方法名和参数列表合起来被称为 **方法签名**。

`System.getProperties().list(System.out);` 可以提供环境信息





**参考链接**

https://www.liaoxuefeng.com/wiki/1252599548343744