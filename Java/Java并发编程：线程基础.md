# 学习前言：
- 本模块是在下学习Java并发的一些记录和思考，若有不正之处，请多多谅解并欢迎指正。
- 开头会抛出几道常见面试题，引出本篇的内容。
- 如果你有想法或建议，可以评论或者私信我  wangjie2yd@gmail.com 
- : )

# 面试问题
Q : 线程和进程的区别?  
Q : 线程的实现方式?  
Q : 为什么要使用多线程?  
Q : 线程的生命周期和状态?   

# 进程和线程
## 1.1进程
### 1.1.1进程的由来
进程的由来涉及到操作系统的发展历史，早期的计算机只能用来解决数学计算问题。因为很多大量的计算通过人力去完成是很耗时间和人力成本的。最初的计算机，只能接受一些特定指令，用户输入一个指令，计算机就做一个操作，假设用户输入指令和读取数据需要10s，计算可能只需要0.01s，计算机绝大多数都处于等待用户输入的状态，显然这样效率很低。  

那么能不能把一系列需要输入的指令都提前写好，形成一个清单，然后一次性交给计算机，这样计算机就可以不断读取指令来进行相应的操作，于是，批处理操作系统就诞生了。这样就提高了任务处理的便捷性，减少用户输入指令时间。

但是仍然存在一个问题：数据读取（I/O操作）所需要的CPU资源非常少。大部分工作是分派给DMA（Direct Memory Access）直接内存完成的。在DMA读取数据的时候，CPU是空闲的，只能等待当前的任务读取完数据才能继续执行，这样就白白浪费了CPU资源，于是人们在想，能否让CPU在等待A任务读取数据期间，去执行B任务，当A任务读取完后，暂停B任务，继续执行A任务？

> 可以打开Windows的任务管理器，复制一个大文件，你会发现，磁盘利用率会持续增大，而CPU的利用率则会稍微增大一些，然后恢复正常，这个变化过程就是CPU给DMA分派任务

这样就有一个新的问题，原来每次都是一个程序在计算机里面运行，也就说内存中始终只有一个程序的运行数据。而如果想要任务A执行I/O操作的时候，让任务B去执行，必然内存中要装入多个程序，那么如何处理呢？多个程序使用的数据如何进行辨别呢？并且当一个程序运行暂停后，后面如何恢复到它之前执行的状态呢？

这个时候人们就发明了进程，用进程来对应一个程序，每个进程对应一定的内存地址空间，并且只能使用它自己的内存空间，各个进程间互不干扰。并且进程保存了程序每个时刻的运行状态，这样就为进程切换提供了可能。当进程暂停时，它会保存当前进程的状态（比如进程标识、进程的使用的资源等），在下一次重新切换回来时，便根据之前保存的状态进行恢复，然后继续执行。

### 1.1.2并行和并发
进程的出现，使得操作系统的并发成为可能，注意这里说的是 并发 而不是 并行 。这两者在概念上截然不同。    
并发： 从宏观上看起来同一时间段，多个任务都在执行，但具体的某一时间点，只有一个任务在使用CPU（针对单核CPU来说），cpu把这个时间段分片给多个任务，由于整个时间段很小，所以我们感觉CPU好像在同时运行这些任务。  
并行： 同一时间点，多个任务同时执行，单核CPU无法做到，而多核CPU可以。
 
### 1.1.3
进程是程序的一次执行过程，是受操作系统管理的基本运行单元。同时也是操作系统分配资源的最小单元。  
在现代的操作系统比如 Windows、Linux、UNIX、Mac OS X等，都是支持多任务的操作系统。意味着操作系统可以同时运行多个任务，打个比方，你也可以一边听歌，一边玩游戏。至少同时有2个任务正在运行。还有很多任务悄悄地在后台同时运行着，只是桌面上没有显示而已。这里其实刚才讲的并发。

![1-进程展示.jpg](./images/1-进程展示.jpg)
Google chrome浏览器为例，讲解了使用多进程构架的浏览器

  360浏览器是一个进程、WPS也是一个进程，正在操作系统中运行的".exe"都可以理解为一个进程

     

## 线程
线程是操作系统调度的最小单元
线程是最小的执行单元，而进程由至少一个线程组成。如何调度进程和线程，完全由操作系统决定，程序自己不能决定什么时候执行，执行多长时间

   在 Java 中，当我们启动 main 函数时其实就是启动了一个 JVM 的进程，而 main 函数所在的线程就是这个进程中的一个线程，也称主线程。 
        线程与进程相似，但线程是一个比进程更小的执行单位。一个进程在其执行的过程中可以产生多个线程。与进程不同的是同类的多个线程共享进程的堆和方法区资源，
        但每个线程有自己的程序计数器、虚拟机栈和本地方法栈，所以系统在产生一个线程，或是在各个线程之间作切换工作时，负担要比进程小得多，也正因为如此，线程也被称为轻量级进程。

   2. 程序计数器为什么是私有的?
        在多线程的情况下，程序计数器用于记录当前线程执行的位置，从而当线程被切换回来的时候能够知道该线程上次运行到哪儿了，程序计数器私有主要是为了线程切换后能恢复到正确的执行位置。

    3. 虚拟机栈和本地方法栈为什么是私有的? 
        虚拟机栈： 每个 Java 方法在执行的同时会创建一个栈帧用于存储局部变量表、操作数栈、常量池引用等信息。从方法调用直至执行完成的过程，就对应着一个栈帧在 Java 虚拟机栈中入栈和出栈的过程。
        本地方法栈： 和虚拟机栈所发挥的作用非常相似，区别是： 虚拟机栈为虚拟机执行 Java 方法 （也就是字节码）服务，而本地方法栈则为虚拟机使用到的 Native 方法服务。 在 HotSpot 虚拟机中和 Java 虚拟机栈合二为一。
        所以，为了保证线程中的局部变量不被别的线程访问到，虚拟机栈和本地方法栈是线程私有的。

    4. 一句话简单了解堆和方法区
        堆和方法区是所有线程共享的资源，其中堆是进程中最大的一块内存，主要用于存放新创建的对象 (所有对象都在这里分配内存)，方法区主要用于存放已被加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。


## 进程和线程的区别

# 为什么要使用多线程
    6. 为什么要使用多线程呢?
        先从总体上来说：
            从计算机底层来说： 线程可以比作是轻量级的进程，是程序执行的最小单位,线程间的切换和调度的成本远远小于进程。另外，多核 CPU 时代意味着多个线程可以同时运行，这减少了线程上下文切换的开销。
            从当代互联网发展趋势来说： 现在的系统动不动就要求百万级甚至千万级的并发量，而多线程并发编程正是开发高并发系统的基础，利用好多线程机制可以大大提高系统整体的并发能力以及性能。
        再深入到计算机底层来探讨：
            单核时代：
                在单核时代多线程主要是为了提高 CPU 和 IO 设备的综合利用率。举个例子：当只有一个线程的时候会导致 CPU 计算时，IO 设备空闲；进行 IO 操作时，CPU 空闲。
                我们可以简单地说这两者的利用率目前都是 50%左右。但是当有两个线程的时候就不一样了，当一个线程执行 CPU 计算时，另外一个线程可以进行 IO 操作，这样两个的利用率就可以在理想情况下达到 100%了。
            多核时代: 
                多核时代多线程主要是为了提高 CPU 利用率。举个例子：假如我们要计算一个复杂的任务，我们只用一个线程的话，CPU 只会一个 CPU 核心被利用到，
                而创建多个线程就可以让多个 CPU 核心被利用到，这样就提高了 CPU 的利用率。

    7.使用多线程可能带来什么问题?
        并发编程的目的就是为了能提高程序的执行效率提高程序运行速度，但是并发编程并不总是能提高程序运行速度的，而且并发编程可能会遇到很多问题，比如：内存泄漏、上下文切换、死锁还有受限于硬件和软件的资源闲置问题。


# Java中线程的实现方式

# 线程的生命周期和状态
### 线程状态的转换
![6-线程状态转换图.jpg](./images/6-线程状态转换图.jpg)

- 新建(new):当线程被创建时,它只会短暂地处于这种状态。此时它已经分配了必需的系统资源,并执行了初始化。此刻线程已经有资格获得CPU时间了,之后调度器将把这个线程转变为可运行状态或阻塞状态。
- 就绪(Runnable):在这种状态下,只要调度器把时间片分配给线程,线程就可以运行。也就是说,在任意时刻,线程可以运行也可以不运行。只要调度器能分配时间片给线程,它就可以运行,这不同于死亡和阻塞状态。
- 阻塞(Blocked):线程能够运行,但有某个条件阻止它的运行。当线程处于阻塞状态时,调度器将忽略线程,不会分配给线程任何CPU时间。直到线程重新进入了就绪状态,它才有可能执行操作。
- 死亡(Dead):处于死亡或终止状态的线程将不再是可调度的,并且再也不会得到CPU时间,它的任务已结束,或不再是可运行的。任务死亡的通常方式是从run0方法返回,但是任务

    8. 说说线程的生命周期和状态?   
        线程创建之后它将处于 NEW（新建） 状态
        调用 start() 方法后开始运行，线程这时候处于 READY（可运行） 状态。可运行状态的线程获得了 CPU 时间片（timeslice）后就处于 RUNNING（运行） 状态。Java系统将 RUNNABLE 和 RUNNING 这两个状态统称为 RUNNABLE（运行中） 状态 。
        当线程执行 wait()方法之后，线程进入 WAITING（等待） 状态。进入等待状态的线程需要依靠其他线程的通知才能够返回到运行状态，而 TIME_WAITING(超时等待) 状态相当于在等待状态的基础上增加了超时限制，
        比如通过 sleep（long millis）方法或 wait（long millis）方法可以将 Java 线程置于 TIMED WAITING 状态。当超时时间到达后 Java 线程将会返回到 RUNNABLE 状态。
        当线程调用同步方法时，在没有获取到锁的情况下，线程将会进入到 BLOCKED（阻塞） 状态。
        线程在执行 Runnable 的run()方法之后将会进入到 TERMINATED（终止） 状态。



# Reference
《Java 并发编程实战》  
《Java 编程思想(第4版)》  
https://www.cnblogs.com/dolphin0520/p/3910667.html  
https://blog.csdn.net/justloveyou_/article/details/53448157  
https://www.liaoxuefeng.com/wiki/1016959663602400/1017627212385376  

https://github.com/Snailclimb/JavaGuide/blob/master/docs/java/Multithread/JavaConcurrencyBasicsCommonInterviewQuestionsSummary.md#1-什么是线程和进程  

https://www.cnblogs.com/xrq730/p/4850883.html  

https://juejin.im/post/5dc7afa5f265da4d4216c0da#heading-28  