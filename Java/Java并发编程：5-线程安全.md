**前言**： 
上一篇介绍了数据安全性问题，本篇再谈一谈多线程带来的活跃性问题及性能问题。

[TOC]

**面试问题**

## 1.活跃性问题

### 1.1 死锁

一组相互竞争资源的线程因相互等待，导致“永久”阻塞的现象。

这里就不得不说描述死锁的经典例示例——“哲学家进餐”问题，五个哲学家去吃中餐，围坐在一张圆桌旁，他们每个人只有一根筷子，并且放在两个人的中间。哲学家们时而思考，时而吃饭。每个人都需要一双筷子才能吃东西，吃两口后把筷子返回远处，继续思考。

正常情况下五个人不会同时去吃，也就不会出现问题，但如果五个人同时准备吃饭，并且，同时先拿起了他们左手边的筷子，准备去拿他们右手边的筷子，这个时候发现每个人的右手边筷子都被右边的人拿了，大家都在等待右边的人把筷子放下，形成了循环等待，没有一个人可以吃饭，这就形成了一个死锁。

**产生死锁的4个条件**：

- **互斥条件**：使用的资源无法共享，任意一个时刻只由一个线程占用。一根筷子每次只能被一个人用。

- **占有且等待**：至少有一个任务必须持有资源且正在等待获取一个被别的任务持有的资源。拿着左手的筷子，等待右手的。

- **不可抢占**：线程已获得的资源在末使用完之前不能被其他线程强行剥夺，只有吃完才放筷子，不然一直等，只有自己使用完毕后才释放资源。不能去抢别人的筷子，只能等别人主动把筷子放下。

- **循环等待**：A等待B、B等待A。每个人都等右边的人先放筷子，形成了一个循环等待圈。




**如何避免线程死锁?**  

- **破坏互斥条件**：这个条件我们没有办法破坏，因为临界资源需要互斥访问，为了达到互斥才加锁的。
- **破坏请求与保持条件**： 一次性申请所有的资源，但这样的做法极大的降低资源利用率。把筷子都放桌子中央，需要吃饭的人一次拿两根。筷子不够两根的话，进行等待。
- **破坏不剥夺条件**：占用部分资源的线程进一步申请其他资源时，如果申请不到，可以主动释放它占有的资源。如果拿不到右手的筷子，就把左手的筷子也放下，这种方式需要手动去释放锁，而synchrnized会自动加锁和释放锁，无法手动去释放，J.U.C中的Lock可以很好的解决这个问题。
-  **破坏循环等待条件**：依靠按序申请资源来预防。按某一顺序申请资源，释放资源则反序释放。前四个人都是先拿左再拿右，可以让最后一个人先拿右再拿左，如果将筷子放在桌子中央可以对筷子进行标号1到5，从小到大申请顺序，这样就不会发生循环等待了。

### 1.2 活锁

活锁是另一种活跃性问题，该问题尽管不会阻塞线程，但也不能继续执行任务。例如两个互相协作的线程都修改对方的状态，就像两个过于礼貌的人在半路上面对面的相遇，他们彼此给对方让路，然后又在另一条路上相遇了，于是就陷入了这种反复避让的循环中，谁也无法通过。

解决的方案很简单，只需要在重试机制中加入随机性，谦让时等待一个随机时间，这样再次相撞的概率就很低了。

### 1.3 饥饿

饥饿则是指线程因无法及时访问所需资源，这里的资源包括CPU时钟周期及需要互斥访问的共享资源，之前在介绍Thread的时候，其 **priority** 代表的就是线程的优先级，优先级高的更容易分配的CPU的执行权。同理，优先级低的不容易分配到CPU的执行权，如果CPU繁忙的情况下，优先级低的线程拿不到执行权，就可能发生线程“饥饿”，持有锁的线程，执行时间过长，也可能导致“饥饿”问题。

Thread API中定义的优先级只能作为线程调度的参考，JVM会根据Thread类的10个优先级映射到操作系统的调度优先级，这种映射可能是不对等的，不同操作系统的优先级个数可能不同，但肯定有最高、最低和正常这三个标准，这也就是Thread类中只定义了三种优先级（MIN_PRIORITY、NORM_PRIORITY和MAX_PRIORITY）的原因。

因此避免使用线程优先级来支持程序的线程安全，这会增加平台依赖性，且可能会导致活跃性问题，大部分情况下，使用默认的线程优先级即可。

解决“饥饿”问题也很简单，三种方案：一是保证资源充足；二是避免持有锁的线程长时间执行；三是公平的分配资源。

## 2.性能问题

一个同步方法可/以调用另外一个同步方法，一个线程已经拥有了某个对象的锁，再次申请的时候仍然会得到该对象的锁
也就是说synchronized获得的锁是可重入的， 子类的synchronized方法可以访问父类的synchronoized方法

ThreadLoacl

ThreadLocal线程局部变量 ThreadLocal是使用空间换时间, synchronized是使用时间换空间
比如在hibernate中session就存在与ThreadLocal中,避免synchronized的使用

24. synchronized与ThreadLocal的比较
    （1）ThreadLocal使用场合主要解决多线程中数据因并发产生的不一致问题。ThreadLocal为每个线程中并发访问的数据提供一个副本，通过访问副本来运行业务，这样的结果是耗费了内存，但大大减少了线程同步所带来的性能消耗，也减少了线程并发控制的复杂度；

    （2）ThreadLocal不能使用原子类型，只能使用Object类型。ThreadLocal的使用要比synchronized简单得多；

    （3）ThreadLocal和synchronized都用于解决多线程并发的访问，但是二者有本质区别：synchronized是利用锁的机制，使变量或代码块在某一时刻只能被一个线程访问，而ThreadLocal为每一个线程都提供了变量的副本，使每个线程在某一时间访问到的并不是同一个对象，这样就隔离了多个线程对数据的共享。而synchronized却正好相反，它用于多个线程间通信时能够获取数据共享；

    （4）同步会带来巨大的性能开销，所以同步操作应该是细粒度的（对象中的不同元素使用不同的锁，而不是整个对象一个锁），如果同步使用得当，带来的性能开销是微不足道的，使用同步真正的风险是复杂性和可能破坏资源安全，而不是性能；

    （5）synchronized用于线程间的数据共享，ThreadLocal用于线程间的数据隔离。
    ThreadLocal：数据隔离，适合多个线程需要多次使用同一个对象，并且需要该对象具有相同的初始化值时；
    synchronized：数据同步，当多个线程想访问或修改同一个对象，需要阻塞其它线程从而只允许其中一个线程对其进行访问与修改。


14. 如何实现线程同步
    (1) synchronized 关键字，修饰代码块、方法或静态方法
        同步是一种高开销的操作，因此应该尽量减少同步的内容。通常没有必要同步整个方法，使用synchronized代码块同步关键代码即可。
    (2) ReentrantLock 
        在Java5中新增了java.util.concurrent包来支持同步。ReentrantLock类是可重入、互斥、实现了Lock接口的锁，它与使用synchronized方法和块具有相同的基本行为和语义，并且扩展了其能力。
        ReentrantLock类的常用方法有：
        ReentrantLock()：创建一个ReentrantLock实例；
        lock()：获得锁；
        unlock()：释放锁；
        注：ReentrantLock还有一个可以创建公平锁的构造方法，但由于会大幅降低程序运行效率，不推荐使用。

    (3) ThreadLocal 实现线程同步
        使用ThreadLocal管理变量，则每个使用该变量的线程都获得该变量的一个副本，副本之间相互独立，这样每个线程都可以随意更改自己的变量副本，而不会对其它线程产生影响。



10. 
    
18. 什么是线程安全，Servlet、变量是线程安全的吗
    线程安全：如果你的代码在多线程下执行和单线程下执行永远都能获得一样的结果，那么你的代码就是线程安全的。
    线程安全问题都是由全局变量及静态变量引起。若每个线程中对全局变量、静态变量只有读操作，而无写操作，一般来说，这是线程安全的；若有多个线程同时执行写操作，一般都需要考虑线程同步，否则就可能影响线程安全。
    Servlet不是线程安全的，Servlet是单实例多线程的，当多个线程同时访问同一个方法，是不能保证共享变量的线程安全的；
    静态变量：线程非安全。static变量被所有实例共享，当声明类变量时，不会生成static变量的副本，而是类的所有实例共享同一个static变量。一旦值被修改，其它对象均对修改可见，因此线程非安全。
    实例变量：单例时线程非安全，非单例时线程安全。实例变量是实例对象私有的，若系统中只存在一个实例对象，则在多线程下，值改变则对其它对象都可见，所以线程非安全的；每个线程都在不同实例对象中执行，则对象之间的修改互不影响，线程安全。
    局部变量：线程安全。定义在方法内部的变量，线程间不共享。
    静态方法：方法中如果没有使用静态变量，就没有线程安全问题；静态方法内部的变量是局部变量。
