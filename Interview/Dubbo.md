## 为什么要进行系统拆分？如何进行系统拆分？拆分以后不用dubbo可以吗？
方便项目的开发，测试，部署和迭代，解决代码冲突
拆分的话，分多轮拆，可以按层拆分，也可以按模块拆分 云童康养
不使用dubbo，还可以使用springcloud，不用rpc，通过http协议也是可以实现系统间通信的，不过代价比较高

## dubbo工作原理
- 第一层：service层,接口层，服务提供者和消费者提供 ，需要手动实现
- 第二层：config层，配置层，任何一个框架，都需要提供配置文件，来配置框架
- 第三层：proxy层，代理层，无论是consumer还是provider，dubbo都会生成代理，代理之间进行网络通信
- 第四层：registry层，注册层，provider注册自己作为一个服务，consumer就可以去注册中心找要调用的服务
- 第五层：cluster层，集群层，provider可以部署在多台机器上，多个provider就组成了一个集群
- 第六层：monitor层，监控层，consumer调用provider，调用了多少次，统计信息监控
- 第七层：protocol层，协议层，负责具体的provider和consumer之间调用接口的网络通信
- 第八层：exchange层，信息交换层，封装请求响应模式，同步转异步
- 第九层：transport层，网络传输层，抽象mina和netty为统一接口
- 第十层：serialize层,数据序列化层

## 工作流程
![01_dubbo的工作原理](./img/01_dubbo的工作原理.png)


## 注册中心挂了可以继续通信吗？
可以，因为刚开始初始化的时候，消费者会将提供者的地址等信息拉取到本地缓存，所以注册中心挂了可以继续通信。


## dubbo支持哪些通信协议和序列化协议？
- dubbo协议  
dubbo://192.168.0.1:20188  
默认使用的是dubbo协议，单一长连接，NIO异步通信，基于 hessian 作为序列化协议  
适用的场景是：传输的数据量很小，100kb以内，consumer远远多于provider 并发量很高  

- rmi协议  
使用java二进制序列化，多个短连接，适合consumer和provider数量差不多，适用于文件的传输

- hessian协议  
使用hessian序列化，多个短连接，适用于provider多于consumer，适用于文件传输

- http协议  
使用jsonxulxh

- webservice  
使用SOAP文本序列化

## dubbo支持哪些负载均衡、高可用（集群容错）以及动态代理生成的策略？
负载均衡策略：  
- random loadbalance  
随机调用实现负载均衡，可以根据不同provider的机器环境设置权重，权重越大分配的流量越高

- roundrobin loadbalance  
默认会均匀地将流量分发到各个机器上，如果机器性能不同，性能差的机器会造成负载过高，需要调整权重  

- leastactive loadbalance    
dubbo自动感知，某个机器的性能越差，那么接收的请求越少  

- consistanthash loadbalance  
一致性的hash算法，如果需要一类请求都到一个节点上，使用这个一致性hash策略  



dubbo集群容错策略：  
- failover cluster模式  
失败自动切换，自动重试其他机器，常见于读操作   

- failfast cluster模式   
一次调用失败就立即失败，常见于写操作  

- failsafe cluster模式  
出现异常时忽略掉，常用于不重要的接口调用，比如记录日志  

- failback cluster模式  
失败了后台自动记录请求，然后定时重发，比较适合于写消息队列  

- forking cluster模式  
并行调用多个provicer，只要一个成功就理解返回  

- broadcast cluster模式  
逐个调用所有的cluster  



dubbo动态代理策略：  
默认使用javassist动态字节码生成，创建代理类  
可以通过SPI扩展机制配置自己的动态代理策略

## dubbo的SPI机制？基于SPI机制对dubbo进行扩展
SPI（service provider interface），如果一个接口有3个实现类，那么系统运行的时候对这个接口到底选择哪个实现类。这就需要SPI了，需要根据指定的配置或是默认的配置，找到对应的实现类加载进来，然后用这个实现类的实例对象  
经典的思想体现：jdbc  java定义了一套jdbc接口，但是没有提供jdbc的实现类  
使用不同的数据库，可以通过导入不同的jdbc驱动来实现  
dubbo也使用了SPI思想，不过没有使用JDK的SPI机制，而是自己实现的一套SPI机制  


## 基于dubbo进行服务治理、服务降级及超时重试
### 服务治理：
- 调用链路自动生成  
记录各个服务之间的调用，将服务之间的依赖关系和调用链路以图片的形式来呈现
- 服务访问压力以及时长统计
自动统计各个接口和服务之间的调用次数已经访问延时，而且要分为两个级别  
一是接口粒度，就是每个服务的每个接口每天被调用多少次，请求延时分别是多少  
二是从源头开始，一个完整的请求链路后，全天全链路走了多少次，延时分别是多少
- 其它  
服务分层（避免循环依赖）   
调用链路失败监控和报警  
服务鉴权  
每个服务的可用性的监控（接口调用成功率？几个 9？99.99%，99.9%，99%）  

### 服务降级：  
比如说服务 A 调用服务 B，结果服务 B 挂掉了，服务 A 重试几次调用服务 B，还是不行，那么直接降级，走一个备用的逻辑，给用户返回响应。
```xml
<beans>
    <dubbo:application name="dubbo-consumer"  />
    <dubbo:registry address="zookeeper://127.0.0.1:2181" />
    <dubbo:reference id="fooService" interface="com.test.service.FooService"  timeout="10000" check="false" mock="return null">
    </dubbo:reference>
</beans>
```
mock 的值也可以修改为 true，然后再跟接口同一个路径下实现一个 Mock 类，命名规则是 “接口名称+Mock” 后缀。然后在 Mock 类里实现自己的降级逻辑。
```java
public class HelloServiceMock implements HelloService {
    public void sayHello() {
        // 降级逻辑
    }
}
```

### 超时重试：  
所谓超时重试，就是 consumer 调用 provider 要是失败了，比如抛异常了，此时应该是可以重试的，或者调用超时了也可以重试。  
配置如下：
```xml
<dubbo:reference id="xxxx" interface="xx" check="true" async="false" retries="3" imeout="2000"/>  
```
timeout：一般设置为 200ms，我们认为不能超过 200ms 还没返回。  
retries：设置 retries，一般是在读请求的时候，比如你要查询个数据，你可以设置个 retries，如果第一次没读到，报错，重试指定的次数，尝试再次读取。

## 分布式系统接口的幂等性
这个不是技术问题，具体需要结合业务来保证幂等性，针对核心业务保证幂等性  
其实保证幂等性主要是三点：
- 对于每个请求必须有一个唯一的标识，举个栗子：订单支付请求，肯定得包含订单 id，一个订单 id 最多支付一次，对吧。
- 每次处理完请求之后，必须有一个记录标识这个请求处理过了。常见的方案是在 mysql 中记录个状态啥的，比如支付之前记录一条这个订单的支付流水。
- 每次接收请求需要进行判断，判断之前是否处理过。比如说，如果有一个订单已经支付了，就已经有了一条支付流水，那么如果重复发送这个请求，则此时先插入支付流水，orderId 已经存在了，唯一键约束生效，报错插入不进去的。然后你就不用再扣款了。

## 分布式的接口调用的顺序性
从业务逻辑上设计的这个系统最好是不需要这种顺序性的保证，因为一旦引入顺序性保障，比如使用分布式锁，会导致系统复杂度上升，而且会带来效率低下，热点数据压力过大等问题。

下面我给个我们用过的方案吧，简单来说，首先你得用 dubbo 的一致性 hash 负载均衡策略，将比如某一个订单 id 对应的请求都给分发到某个机器上去，接着就是在那个机器上，因为可能还是多线程并发执行的，你可能得立即将某个订单 id 对应的请求扔一个内存队列里去，强制排队，这样来确保他们的顺序性。

![02_分布式的接口调用的顺序性.png](./img/02_分布式的接口调用的顺序性.png)

但是这样引发的后续问题就很多，比如说要是某个订单对应的请求特别多，造成某台机器成热点怎么办？解决这些问题又要开启后续一连串的复杂技术方案......曾经这类问题弄的我们头疼不已，所以，还是建议什么呢？

最好是比如说刚才那种，一个订单的插入和删除操作，能不能合并成一个操作，就是一个删除，或者是其它什么，避免这种问题的产生。

### 分布式锁方案  
100%保证请求的处理顺序，请求到接入服务后，给每个请求封装一个请求的orderId=1和seq=(1/2/3)  
使用zookeeper分布式锁，根据seq的先后来决定请求的处理先后顺序

## 自己如何设计一个类似于dubbo的rpc框架
其实问到你这问题，你起码不能认怂，因为是知识的扫盲，那我不可能给你深入讲解什么 kafka 源码剖析，dubbo 源码剖析，何况我就算讲了，你要真的消化理解和吸收，起码个把月以后了。

所以我给大家一个建议，遇到这类问题，起码从你了解的类似框架的原理入手，自己说说参照 dubbo 的原理，你来设计一下，举个例子，dubbo 不是有那么多分层么？而且每个分层是干啥的，你大概是不是知道？那就按照这个思路大致说一下吧，起码你不能懵逼，要比那些上来就懵，啥也说不出来的人要好一些。

举个栗子，我给大家说个最简单的回答思路：

- 上来你的服务就得去注册中心注册吧，你是不是得有个注册中心，保留各个服务的信息，可以用 zookeeper 来做，对吧。
- 然后你的消费者需要去注册中心拿对应的服务信息吧，对吧，而且每个服务可能会存在于多台机器上。
- 接着你就该发起一次请求了，咋发起？当然是基于动态代理了，你面向接口获取到一个动态代理，这个动态代理就是接口在本地的一个代理，然后这个代理会找到服务对应的机器地址。
- 然后找哪个机器发送请求？那肯定得有个负载均衡算法了，比如最简单的可以随机轮询是不是。
- 接着找到一台机器，就可以跟它发送请求了，第一个问题咋发送？你可以说用 netty 了，nio 方式；第二个问题发送啥格式数据？你可以说用 hessian 序列化协议了，或者是别的，对吧。然后请求过去了。
- 服务器那边一样的，需要针对你自己的服务生成一个动态代理，监听某个网络端口了，然后代理你本地的服务代码。接收到请求的时候，就调用对应的服务代码，对吧。

这就是一个最最基本的 rpc 框架的思路，先不说你有多牛逼的技术功底，哪怕这个最简单的思路你先给出来行不行？