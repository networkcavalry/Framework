- 什么是线程？  
进程是操作系统分配资源的最小单位，线程是CPU调度的基本单位，一个进程可以同时拥有多个线程，线程同享进程资源且每个线程都含有少量私有资源

- 什么是线程安全？  
在多线程并发的情况下，程序总是能正常预期的执行。

- 什么是自旋锁？  
是JDK1.5之后引入获取锁的一种优化，尝试获取锁失败后，不会立即被操作系统挂起，而是段短时间内不停轮询检查要获取的锁有没有没释放，因为被操作系统挂起需要等待8w个时钟周期才能再次被调用

- 什么是Java内存模型？
便于java使用者的一种对JVM内存结构的划分，主要分堆，方法区，和栈  

- 什么是CAS？  
- Compare-and-Swap,是解决并发算法的一种常用实现，对共享数据的修改不再是直接去操作共享数据，而是先去复制共享数据到本地线程栈，在本地执行修改操作后，再和共享数据做比较，如果相同，这说明在这期间，共享数据未被其他线程修改，则将本地的数据替换共享的数据（修改指针地址），如果不同，则放弃体替换，重新执行一遍该流程，其中的比较和替换是一个原子操作，不会发生竟态条件

- 什么是乐观锁和悲观锁？
乐观锁是每次获取锁后，都觉得共享数据没有被修改

- 什么是AQS？
AQS是java.util.concurrent包的基石，定义了一套多线程访问共享资源的同步框架，如Lock、ReadWriteLock、CountDownLatch、CyclicBarrier、Semphore、ThreadPoolExecutor都是建立在AQS的基础上的。

- 什么是原子操作？在Java Concurrency API中有哪些原子类(atomic classes)？
原子操作顾名思义就是操作有原子性，即不可分割的操作，要么都成功要么都失败  
除了8大基本类型的原子类，还有AtomicRefence、AtomicStampedReference、AtomicIntergerArray、AtomicIntegerFieldUpdater

- 什么是Executors框架？
- 什么是阻塞队列？如何使用阻塞队列来实现生产者-消费者模型？
- 什么是Callable和Future?
- 什么是FutureTask?
- 什么是同步容器和并发容器的实现？
- 什么是多线程？优缺点？
- 什么是多线程的上下文切换？
- ThreadLocal的设计理念与作用？
- ThreadPool（线程池）用法与优势？
- Concurrent包里的其他东西：ArrayBlockingQueue、CountDownLatch等等。
- synchronized和ReentrantLock的区别？
- Semaphore有什么作用？
- Java Concurrency API中的Lock接口(Lock interface)是什么？对比同步它有什么优势？
- Hashtable的size()方法中明明只有一条语句”return count”，为什么还要做同步？
- ConcurrentHashMap的并发度是什么？
- ReentrantReadWriteLock读写锁的使用？
- CyclicBarrier和CountDownLatch的用法及区别？
- LockSupport工具？
- Condition接口及其实现原理？
- Fork/Join框架的理解?
- wait()和sleep()的区别?
- 线程的五个状态（五种状态，创建、就绪、运行、阻塞和死亡）?
- start()方法和run()方法的区别？
- Runnable接口和Callable接口的区别？
- volatile关键字的作用？
- Java中如何获取到线程dump文件？
- 线程和进程有什么区别？
- 线程实现的方式有几种（四种）？
- 高并发、任务执行时间短的业务怎样使用线程池？并发不高、任务执行时间长的业务怎样使用线程池？并发高、业务执- 行时间长的业务怎样使用线程池？
- 如果你提交任务时，线程池队列已满，这时会发生什么？
- 锁的等级：方法锁、对象锁、类锁?
- 如果同步块内的线程抛出异常会发生什么？
- 并发编程（concurrency）并行编程（parallellism）有什么区别？
- 如何保证多线程下 i++ 结果正确？
- 一个线程如果出现了运行时异常会怎么样?
- 如何在两个线程之间共享数据?
- 生产者消费者模型的作用是什么?
- 怎么唤醒一个阻塞的线程?
- Java中用到的线程调度算法是什么
- 单例模式的线程安全性?
- 线程类的构造方法、静态块是被哪个线程调用的?
- 同步方法和同步块，哪个是更好的选择?
- 如何检测死锁？怎么预防死锁？