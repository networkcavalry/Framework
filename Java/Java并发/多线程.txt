多线程
    1. 进程和线程的区别？
        进程是程序的一次执行过程，是系统运行程序的基本单位。
        在 Java 中，当我们启动 main 函数时其实就是启动了一个 JVM 的进程，而 main 函数所在的线程就是这个进程中的一个线程，也称主线程。 
        线程与进程相似，但线程是一个比进程更小的执行单位。一个进程在其执行的过程中可以产生多个线程。与进程不同的是同类的多个线程共享进程的堆和方法区资源，
        但每个线程有自己的程序计数器、虚拟机栈和本地方法栈，所以系统在产生一个线程，或是在各个线程之间作切换工作时，负担要比进程小得多，也正因为如此，线程也被称为轻量级进程。

    2. 程序计数器为什么是私有的?
        在多线程的情况下，程序计数器用于记录当前线程执行的位置，从而当线程被切换回来的时候能够知道该线程上次运行到哪儿了，程序计数器私有主要是为了线程切换后能恢复到正确的执行位置。

    3. 虚拟机栈和本地方法栈为什么是私有的? 
        虚拟机栈： 每个 Java 方法在执行的同时会创建一个栈帧用于存储局部变量表、操作数栈、常量池引用等信息。从方法调用直至执行完成的过程，就对应着一个栈帧在 Java 虚拟机栈中入栈和出栈的过程。
        本地方法栈： 和虚拟机栈所发挥的作用非常相似，区别是： 虚拟机栈为虚拟机执行 Java 方法 （也就是字节码）服务，而本地方法栈则为虚拟机使用到的 Native 方法服务。 在 HotSpot 虚拟机中和 Java 虚拟机栈合二为一。
        所以，为了保证线程中的局部变量不被别的线程访问到，虚拟机栈和本地方法栈是线程私有的。

    4. 一句话简单了解堆和方法区
        堆和方法区是所有线程共享的资源，其中堆是进程中最大的一块内存，主要用于存放新创建的对象 (所有对象都在这里分配内存)，方法区主要用于存放已被加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。

    5.说说并发与并行的区别?
        并发： 同一时间段，多个任务都在执行 (单位时间内不一定同时执行)；
        并行： 同一时间点，多个任务同时执行。

    6. 为什么要使用多线程呢?
        先从总体上来说：
            从计算机底层来说： 线程可以比作是轻量级的进程，是程序执行的最小单位,线程间的切换和调度的成本远远小于进程。另外，多核 CPU 时代意味着多个线程可以同时运行，这减少了线程上下文切换的开销。
            从当代互联网发展趋势来说： 现在的系统动不动就要求百万级甚至千万级的并发量，而多线程并发编程正是开发高并发系统的基础，利用好多线程机制可以大大提高系统整体的并发能力以及性能。
        再深入到计算机底层来探讨：
            单核时代：
                在单核时代多线程主要是为了提高 CPU 和 IO 设备的综合利用率。举个例子：当只有一个线程的时候会导致 CPU 计算时，IO 设备空闲；进行 IO 操作时，CPU 空闲。
                我们可以简单地说这两者的利用率目前都是 50%左右。但是当有两个线程的时候就不一样了，当一个线程执行 CPU 计算时，另外一个线程可以进行 IO 操作，这样两个的利用率就可以在理想情况下达到 100%了。
            多核时代: 
                多核时代多线程主要是为了提高 CPU 利用率。举个例子：假如我们要计算一个复杂的任务，我们只用一个线程的话，CPU 只会一个 CPU 核心被利用到，
                而创建多个线程就可以让多个 CPU 核心被利用到，这样就提高了 CPU 的利用率。

    7.使用多线程可能带来什么问题?
        并发编程的目的就是为了能提高程序的执行效率提高程序运行速度，但是并发编程并不总是能提高程序运行速度的，而且并发编程可能会遇到很多问题，比如：内存泄漏、上下文切换、死锁还有受限于硬件和软件的资源闲置问题。

    8. 说说线程的生命周期和状态?   
        图 1
        线程创建之后它将处于 NEW（新建） 状态
        调用 start() 方法后开始运行，线程这时候处于 READY（可运行） 状态。可运行状态的线程获得了 CPU 时间片（timeslice）后就处于 RUNNING（运行） 状态。Java系统将 RUNNABLE 和 RUNNING 这两个状态统称为 RUNNABLE（运行中） 状态 。
        当线程执行 wait()方法之后，线程进入 WAITING（等待） 状态。进入等待状态的线程需要依靠其他线程的通知才能够返回到运行状态，而 TIME_WAITING(超时等待) 状态相当于在等待状态的基础上增加了超时限制，
        比如通过 sleep（long millis）方法或 wait（long millis）方法可以将 Java 线程置于 TIMED WAITING 状态。当超时时间到达后 Java 线程将会返回到 RUNNABLE 状态。
        当线程调用同步方法时，在没有获取到锁的情况下，线程将会进入到 BLOCKED（阻塞） 状态。
        线程在执行 Runnable 的run()方法之后将会进入到 TERMINATED（终止） 状态。

    9.什么是上下文切换?
        多线程编程中一般线程的个数都大于 CPU 核心的个数，而一个 CPU 核心在任意时刻只能被一个线程使用，为了让这些线程都能得到有效执行，CPU 采取的策略是为每个线程分配时间片并轮转的形式。
        当一个线程的时间片用完的时候就会重新处于就绪状态让给其他线程使用，这个过程就属于一次上下文切换。
        概括来说就是：当前任务在执行完 CPU 时间片切换到另一个任务之前会先保存自己的状态，以便下次再切换会这个任务时，可以再加载这个任务的状态。任务从保存到再加载的过程就是一次上下文切换。
        上下文切换通常是计算密集型的。也就是说，它需要相当可观的处理器时间，在每秒几十上百次的切换中，每次切换都需要纳秒量级的时间。所以，上下文切换对系统来说意味着消耗大量的 CPU 时间，事实上，可能是操作系统中时间消耗最大的操作。
        Linux 相比与其他操作系统（包括其他类 Unix 系统）有很多的优点，其中有一项就是，其上下文切换和模式切换的时间消耗非常少。

    10. 什么是线程死锁?如何避免死锁?
        产生死锁必须具备以下四个条件：
            互斥条件：该资源任意一个时刻只由一个线程占用。
            请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。
            不剥夺条件:线程已获得的资源在末使用完之前不能被其他线程强行剥夺，只有自己使用完毕后才释放资源。
            循环等待条件:若干进程之间形成一种头尾相接的循环等待资源关系。
            破坏互斥条件
         如何避免线程死锁?
            破坏互斥条件        这个条件我们没有办法破坏，因为我们用锁本来就是想让他们互斥的（临界资源需要互斥访问）。
            破坏请求与保持条件  一次性申请所有的资源。(极大的降低资源利用率)
            破坏不剥夺条件      占用部分资源的线程进一步申请其他资源时，如果申请不到，可以主动释放它占有的资源。(自己申请不到，就主动释放自己的资源)
            破坏循环等待条件    靠按序申请资源来预防。按某一顺序申请资源，释放资源则反序释放。破坏循环等待条件。(按顺序访问资源，降低资源利用率)

    11. 为什么我们调用 start() 方法时会执行 run() 方法，为什么我们不能直接调用 run() 方法？
            ( 调用 start 方法方可启动线程并使线程进入就绪状态，直接调用 run 方法只是 在主线程里执行 thread 的一个普通方法调用 )
            new 一个 Thread，线程进入了新建状态;调用 start() 方法，会启动一个线程并使线程进入了就绪状态，当分配到时间片后就可以开始运行了。 
            start() 会执行线程的相应准备工作，然后自动执行 run() 方法的内容，这是真正的多线程工作。 而直接执行 run() 方法，会把 run 方法当成一个 main 线程下的普通方法去执行，并不会在某个线程中执行它，所以这并不是多线程工作。

    12. 说说 sleep() 方法和 wait() 方法区别和共同点?
            两者最主要的区别在于：sleep 方法没有释放锁，而 wait 方法释放了锁 。
            两者都可以暂停线程的执行。
            Wait 通常被用于线程间交互/通信，sleep 通常被用于暂停执行。
            wait() 方法被调用后，线程不会自动苏醒，需要别的线程调用同一个对象上的 notify() 或者 notifyAll() 方法。sleep() 方法执行完成后，线程会自动苏醒。或者可以使用wait(long timeout)超时后线程会自动苏醒。

    13. 线程的优先级分几级，默认级别是什么
            优先级分为1-10共10个等级，1表示最低优先级，5是默认级别；
            t.setPriority()用来设定线程的优先级，需要在线程开始方法被调用之前进行设定；
            可以使用MIN_PRIORITY（1），MAX_PRIORITY（10），NORM_PRIORITY（5）来设定优先级。
            
    14. 如何实现线程同步
        (1) synchronized 关键字，修饰代码块、方法或静态方法
            同步是一种高开销的操作，因此应该尽量减少同步的内容。通常没有必要同步整个方法，使用synchronized代码块同步关键代码即可。
        (2) ReentrantLock 
            在Java5中新增了java.util.concurrent包来支持同步。ReentrantLock类是可重入、互斥、实现了Lock接口的锁，它与使用synchronized方法和块具有相同的基本行为和语义，并且扩展了其能力。
            ReentrantLock类的常用方法有：
            ReentrantLock()：创建一个ReentrantLock实例；
            lock()：获得锁；
            unlock()：释放锁；
            注：ReentrantLock还有一个可以创建公平锁的构造方法，但由于会大幅降低程序运行效率，不推荐使用。

        (3) ThreadLocal 实现线程同步
            使用ThreadLocal管理变量，则每个使用该变量的线程都获得该变量的一个副本，副本之间相互独立，这样每个线程都可以随意更改自己的变量副本，而不会对其它线程产生影响。
            
    15. HashTable的size方法中明明只有一条语句"return count"，为什么还要做同步
        (同一时间只能有一个线程执行被锁定对象的同步方法，但是对于该对象的非同步方法，可以多条线程同时访问)
        所以，这样就出现了问题，而给size添加了同步之后，意味着线程B调用size方法只有在线程A调用put方法之后，这样就保证了线程安全。

    16. 如何停止一个正在运行的线程
        (1).使用stop方法强行终止线程，不推荐，因为和suspend、resume等一样，都是过期作废的方法，可能产生不可预料的结果；
        (2).使用interrupt方法，而interrupt方法并未真正停止线程，只不过在线程中打了一个标记；此时可以使用抛异常的方式

    17. Runnable与Callable<V>的区别
        Runable 没有返回值，不能抛异常，而Callable<V> 可以,若抛异常 则Future的get方法就什么也取不到了

    18. 什么是线程安全，Servlet、变量是线程安全的吗
        线程安全：如果你的代码在多线程下执行和单线程下执行永远都能获得一样的结果，那么你的代码就是线程安全的。
        线程安全问题都是由全局变量及静态变量引起。若每个线程中对全局变量、静态变量只有读操作，而无写操作，一般来说，这是线程安全的；若有多个线程同时执行写操作，一般都需要考虑线程同步，否则就可能影响线程安全。
        Servlet不是线程安全的，Servlet是单实例多线程的，当多个线程同时访问同一个方法，是不能保证共享变量的线程安全的；
        静态变量：线程非安全。static变量被所有实例共享，当声明类变量时，不会生成static变量的副本，而是类的所有实例共享同一个static变量。一旦值被修改，其它对象均对修改可见，因此线程非安全。
        实例变量：单例时线程非安全，非单例时线程安全。实例变量是实例对象私有的，若系统中只存在一个实例对象，则在多线程下，值改变则对其它对象都可见，所以线程非安全的；每个线程都在不同实例对象中执行，则对象之间的修改互不影响，线程安全。
        局部变量：线程安全。定义在方法内部的变量，线程间不共享。
        静态方法：方法中如果没有使用静态变量，就没有线程安全问题；静态方法内部的变量是局部变量。
    
    19. 线程是否可以被多次调用start方法
        Java的线程是不允许启动两次的，第二次调用必然会抛出IllegalThreadStateException，这是一种运行时异常，多次调用start被认为是编程错误。

    20. 线程池的工作原理
        Executor
            Executor框架是在Java5中引入的，其内部使用了线程池机制，在java.util.concurrent包下，通过该框架来控制线程的启动、执行和关闭，可以简化并发编程的操作。因此，在Java5之后，通过Executor来启动线程比使用Thread的start方法更好，
        除了更易管理，效率更好外，还有关键的一点：有助于避免this逃逸问题：在构造器构造还未彻底完成之前，将自身this引用向外抛出并被其它线程访问，可能会被访问到还未被初始化到的变量，甚至可能会造成更严重的问题。
        
        ExecutorService接口继承自Executor接口，它提供了更丰富的实现多线程的方法，比如，可以调用ExecutorService的shutdown方法来平滑地关闭ExecutorService，调用该方法后，
        将导致ExecutorService停止接收任何新的任务且等待已经提交的任务执行完成（已经提交的任务会分为两类，一类是已经在执行的，另一类是还没有开始执行的），当所有已经提交的任务执行完毕后将会关闭ExecutorService，
        因此我们一般用该接口来实现和管理多线程。

        Executor接口定义了execute方法用来接收一个Runnable接口的对象， 而ExecutorService接口中的submit方法可以接收Runnable和Callable接口的对象。

        ExecutorService的生命周期包括三种状态：运行、关闭、终止。创建后便进入运行状态，当调用了shutdown方法时，便进入关闭状态，此时意味着ExecutorService不再接收新的任务，但它还在执行已经提交了的任务，
        当所有已经提交了的任务执行完成后，便达到终止状态。如果不调用shutdown方法，ExecutorService会一直处于运行状态，不断接收新的任务，服务器一般不需要关闭它，保持一直运行即可。



        (1) newFixedThreadPool(int nThreads)  创建一个指定工作线程数量的线程池。每当提交一个任务就创建一个工作线程，如果工作线程数量达到线程池初始的最大数，则将提交的任务存入到池队列中。 

        (2) newCachedThreadPool()：创建一个可缓存的线程池，调用execute将重用以前构造的线程(如果线程可用)，如果当前没有可用线程，则创建一个新线程并添加到池中，终止并从缓存中移除那些已有60s钟未被使用的线程；

        (3) newSingleThreadPool() 创建只有一个线程的线程池，可以保证任务执行的顺序 且在任意给定的时间不会有多个线程是活动的 .包含一个无界队列，保证所有任务按照指定顺序（FIFO/LIFO/优先级）执行；

        (4) newScheduledThreadPool(int corePoolSize)：创建一个支持定时及周期性任务执行的定长线程池，多数情况下可用来代替Timer类。上一个运行完之后隔2s钟

        (5) newWorkStealingPool()  根据CPU核数，产生相同数目的线程，线程执行完成后会执行其他队列的任务，底层是ForkJoinPool

        (6) newForkJoinPool()      其所有的线程数demon线程(守护线程，精灵线程) JVM不退出，则会在后台一直运行，主线程阻塞才能看到其执行结果
        
        以上方法返回的类型为ExecutorService，调用的构造方法为ThreadPoolExecutor(......)
        核心构造方法ThreadPoolExecutor(......)参数讲解：
        corePoolSize：核心线程池大小；
        maximumPoolSize：最大线程池大小；
        keepAliveTime：线程池中超过corePoolSize数目的空闲线程最大存活时间；
        TimeUnit：keepAliveTime的时间单位；
        workQueue：阻塞任务队列；
        threadFactory（可选）：新建线程工厂；
        RejectedExecutionHandler（可选）：当提交任务数量超过maximumPoolSize+workQueue之和时，任务会交给RejectedExecutionHandler处理。

        其中比较容易让人误解的是：corePoolSize、maximumPoolSize、workQueue之间的关系：
        (1).当线程池小于corePoolSize时，新提交任务将创建一个新线程执行任务，即使此时线程池中存在空闲线程；
        (2).当线程池达到corePoolSize时，新提交任务将被放入workQueue中，等待线程池中任务调度执行；
        (3).当workQueue已满，且maximumPoolSize>CorePoolSize时，新提交的任务会创建新线程执行任务；
        (4).当提交任务数超过maximumPoolSize时，新提交任务由RejectedExecutionHandler处理；
        (5).当线程池中超过corePoolSize线程，空闲时间达到keepAliveTime时，关闭空闲线程；
        (6).当设置allowCoreThreadTimeOut(true)时，线程池中corePoolSize线程空闲时间达到keepAliveTime也将关闭。

    21. 对守护线程的理解
        在Java中有两类线程：User Thread(用户线程)、Daemon Thread(守护线程)
        用个比较通俗的比喻，任何一个守护线程都是整个JVM中所有非守护线程的保姆：只要当前JVM实例中尚存在任何一个非守护线程没有结束，守护线程就全部工作；只有当最后一个非守护线程结束时，守护线程随着JVM一同结束工作。

        退出的先后顺序：非守护线程 > 守护线程 > jvm。
        Daemon的作用是为其它线程的运行提供便利服务，守护线程最典型的应用就是 GC (垃圾回收器)，它就是一个很称职的守护者。

        User和Daemon两者几乎没有区别，唯一的不同之处就在于虚拟机的离开：如果 User Thread已经全部退出运行了，只剩下Daemon Thread存在了，虚拟机也就退出了。因为没有了被守护者，Daemon也就没有工作可做了，也就没有继续运行程序的必要了。

        优先级：守护线程的优先级比较低，用于为系统中的其它对象和线程提供服务。  值得一提的是，守护线程并非只有虚拟机内部提供，用户在编写程序时也可以自己设置守护线程。

        这里有几点需要注意：
        (1) thread.setDaemon(true)必须在thread.start()之前设置，否则会抛出一个IllegalThreadStateException异常。你不能把正在运行的常规线程设置为守护线程。
        (2) 在Daemon线程中产生的新线程也是Daemon的。
        (3) 不要认为所有的应用都可以分配给Daemon来进行服务，比如读写操作或者计算逻辑。

    22. 如何终止线程池
        shutdown：当线程池调用该方法时，线程池的状态立刻变为SHUTDOWN状态。此时，不能再往线程池中添加任何任务，否则将会抛出RejectedExecutionException。但是，此时线程池不会立刻退出，直到添加到线程池中的任务都已经处理完成，才会退出。

        shutdownNow：执行该方法，拒绝接收新提交的任务，（1）线程池的状态立即变为STOP，（2）并试图阻止所有正在执行的线程，（3）不再处理还在线程池队列中等待的任务，当然，它会返回那些未执行的任务。

        它试图阻止线程的方法是通过调用Thread.interrupt方法来实现的，但是这种方法的作用有限，如果线程中没有sleep、wait、Condition、定时锁等应用，interrupt是无法中断当前线程的。所以，shutdownNow并不代表线程池一定会立刻退出，它可能需要等待所有正在执行的任务都执行完毕才会退出。

    23. synchronized与Lock的比较
        (1).Lock是一个接口，而synchronized是Java中的关键字，synchronized是内置的语言实现；
        (2).synchronized在发生异常时，会自动释放线程占有的锁，因此不会导致死锁现象发生；而Lock在发生异常时，如果没有主动通过unLock()去释放锁，则很可能造成死锁现象，因此使用Lock时需要在finally块中释放锁；
        (3).Lock可以让等待锁的线程响应中断，而synchronized却不行，使用synchronized时，等待的线程会一直等待下去，不能够响应中断；
        (4).通过Lock可以知道有没有成功获取锁，而synchronized却无法办到；
        (5).Lock可以提高多个线程进行读操作的效率。
        在性能上来说，如果竞争资源不激烈，两者的性能是差不多的，而当竞争资源非常激烈时（即有大量线程同时竞争），此时Lock的性能要远远优于synchronized。所以说，在具体使用时要根据适当情况选择。

    24. synchronized与ThreadLocal的比较
        （1）ThreadLocal使用场合主要解决多线程中数据因并发产生的不一致问题。ThreadLocal为每个线程中并发访问的数据提供一个副本，通过访问副本来运行业务，这样的结果是耗费了内存，但大大减少了线程同步所带来的性能消耗，也减少了线程并发控制的复杂度；

        （2）ThreadLocal不能使用原子类型，只能使用Object类型。ThreadLocal的使用要比synchronized简单得多；

        （3）ThreadLocal和synchronized都用于解决多线程并发的访问，但是二者有本质区别：synchronized是利用锁的机制，使变量或代码块在某一时刻只能被一个线程访问，而ThreadLocal为每一个线程都提供了变量的副本，使每个线程在某一时间访问到的并不是同一个对象，这样就隔离了多个线程对数据的共享。而synchronized却正好相反，它用于多个线程间通信时能够获取数据共享；

        （4）同步会带来巨大的性能开销，所以同步操作应该是细粒度的（对象中的不同元素使用不同的锁，而不是整个对象一个锁），如果同步使用得当，带来的性能开销是微不足道的，使用同步真正的风险是复杂性和可能破坏资源安全，而不是性能；

        （5）synchronized用于线程间的数据共享，ThreadLocal用于线程间的数据隔离。
        ThreadLocal：数据隔离，适合多个线程需要多次使用同一个对象，并且需要该对象具有相同的初始化值时；
        synchronized：数据同步，当多个线程想访问或修改同一个对象，需要阻塞其它线程从而只允许其中一个线程对其进行访问与修改。

    25. 乐观锁与悲观锁的比较
        悲观锁，就是思想很悲观，每次去拿数据的时候都认为别人会去修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会block直到它拿到锁。传统的关系型数据库中就用到了很多悲观锁的机制，比如行锁，表锁，读锁，写锁等，都是在做操作前先上锁，synchronized也是悲观锁。

        乐观锁，就是思想很乐观，每次去拿数据的时候都认为别人不会去修改，所以不会上锁，但是在更新的时候会去判断一下在此期间别人有没有去更新这个数据，可以使用版本号或时间戳等机制（提交版本必须大于记录当前版本才能执行更新）。像数据库如果提供类似于write_condition机制的其实都是提供的乐观锁，CAS思想也是乐观锁。

        两种锁各有优缺点，乐观锁适用于写比较少读比较多的情况，即冲突真的很少发生的时候，这样可以省去了锁的开销，加大了整个系统的吞吐量。但如果经常产生冲突，上层应用不断进行retry，这样反而降低了性能，所以这种情况下悲观锁比较合适。
        乐观锁事实上并没有使用锁机制。

    26. CyclicBarrier与CountDownLatch的比较
        CountDownLatch：一个或多个线程等待另外N个线程完成某个事情之后才能继续执行。

        CyclicBarrier：N个线程相互等待，任何一个线程完成之前，所有的线程都必须等待。

        对于CountDownLatch来说，重点的是那个“一个线程”，是它在等待，而另外那N个线程在把“某个事情”做完之后可以继续等待，可以终止；而对于CyclicBarrier来说，重点是那“N个线程”，它们之间任何一个没有完成，所有的线程都必须等待。

        CountDownLatch是计数器，线程完成一个就计一个，就像报数一样，只不过是递减的；
        CyclicBarrier更像一个水闸，线程执行就像水流，在水闸处就会堵住，等到水满（线程到齐）了，才开始泄流。

        CountDownLatch不可重复利用，CyclicBarrier可重复利用。

    16. sleep与wait的比较
        (1)/wait是Object类中的方法，sleep是Thread类中的方法；
        (2).sleep是Thread类的静态方法，谁调用，谁睡觉；
        (3).sleep方法调用之后并没有释放锁，使得线程仍然可以同步控制，sleep不会让出系统资源；
        (4).wait是进入线程等待池中等待，让出系统资源；
        (5).调用wait方法的线程，不会自己唤醒，需要线程调用notify/notifyAll方法唤醒等待池中的所有线程，
        才会进入就绪队列中等待系统分配资源。sleep方法会自动唤醒，如果时间不到，想要唤醒，可以使用interrupt方法强行打断；
        (6).sleep可以在任何地方使用，而wait/notify/notifyAll只能在同步控制方法或者同步控制块中使用；
        (7).sleep和wait必须捕获异常，notify/notifyAll不需要捕获异常；
        (8).wait通常被用于线程间交互，sleep通常被用于暂停执行。

    17. sleep与yield的比较
        (1).sleep方法给其它线程运行机会时不考虑线程的优先级，因此会给低优先级的线程以运行的机会；
        yield方法只会给相同或更高优先级的线程以运行的机会；
        (2).sleep方法之后转入阻塞状态，yield方法之后转入就绪状态；
        (3).sleep方法声明抛出InterruptedException，而yield方法没有声明任何异常；
        (4).sleep方法具有更好的可移植性（yield不好控制，只是瞬间放弃CPU的执行权，有可能马上又抢回
        接着执行，而sleep更容易被控制）；
        (5).另外，Thread类的sleep和yield方法将在当前正在执行的线程上运行，所以在其它处于等待状态的
        线程上调用这些方法是没有意义的。这就是为什么这些方法是静态的。它们可以在当前正在执行的线程中
        工作，并避免程序员错误地认为可以在其它非运行线程调用这些方法。

    18. 为什么wait/notify/notifyAll都必须放在同步方法/同步块中
            简单地说，由于wait、notify、notifyAll都是锁级别的操作，所以把它们定义在Object类中，因为锁属于对象。

    19. 对ReadWriteLock的理解
            ReadWriteLock同Lock一样也是一个接口，提供了readLock和writeLock两种锁的操作机制，一个是只读的锁，一个是写锁；
            读锁可以在没有写锁的时候被多个线程同时持有，写锁是独占的（排它的）。每次只能有一个写线程，但是可以有多个线程并发地读数据；
            所有读写锁的实现必须确保写操作对读操作的内存影响，换句话说，一个获得了读锁的线程必须能够看到前一个释放的写锁所更新的内容；
            理论上，读写锁比互斥锁允许对于共享数据更大程度的并发。与互斥锁相比，读写锁是否能够提高性能取决于读写数据的频率、读取和写入操作的持续时间以及读线程和写线程之间的竞争。
            使用场景：假如程序中涉及到一些共享资源的读写操作，并且写操作没有读操作那么频繁。例如，最初填充有数据，然后很少修改的集合，同时频繁搜索，是使用读写锁的理想候选项。
            互斥原则：
            读-读能共存，
            读-写不能共存，
            写-写不能共存。

            public interface ReadWriteLock {
            Lock readLock();
            Lock writeLock();
            }

    20. 同步集合与并发集合的比较
            同步集合：可以简单地理解为通过synchronized实现同步的集合。如果有多个线程调用同步集合的方法，它们将会串行执行；
            并发集合：jdk5的重要特征，增加了并发包java.util.concurrent.*，以CAS为基础。
            常见的并发集合：
            ConcurrentHashMap：线程安全的HashMap实现（ConcurrentHashMap不允许空值或空键，HashMap可以）；
            CopyOnWriteArrayList：线程安全且在读操作时无锁的ArrayList；
            CopyOnWriteArraySet：基于CopyOnWriteArrayList，不添加重复元素；
            ArrayBlockingQueue：基于数组，先进先出，线程安全，可实现指定时间的阻塞读写，并且容量可以限制；
            LinkedBlockingQueue：基于链表实现，读写各用一把锁，在高并发读写操作的情况下，性能优于ArrayBlockingQueue；
            同步集合比并发集合慢得多，主要原因是锁，同步集合会对整个Map或List加锁。






思考题
1: A线程正在执行一个对象中的同步方法, B线程是否可以同时执行同一个对象中的非同步方法?    
    可以，两者不冲突

2:同上, B线程是否可以同时执行同一个对象中的另一个同步方法?  
    一个同步方法可以调用另外一个同步方法，一个线程已经拥有了某个对象的锁，再次申请的时候仍然会得到该对象的锁
    也就是说synchronized获得的锁是可重入的， 子类的synchronized方法可以访问父类的synchronoized方法

3:线程抛出异常会释放锁吗?
    程序在执行过程中,如果出现异常,默认情况锁会被释放,
    所以,在并发处理的过程中,有异常要多加小心,不然可能会发生不一致的情况。
    如,在一个web app处理过程中, 多个servlet线程共同访问同一个资源,这时如果异常处理不合适
    在第一个线程中抛出异常,其他线程就会进入同步代码区,有可能会访问到异常产生时的数据。
    解决方法 copyonwrite

4: volatile和synchronized区别?
    synchronized 锁的其实是 对象，加在方法上锁的是this对象，加在static方法上，则锁的是class的字节码对象
    synchronized 保证原子性和可见性  volatile 保证可见性 
    volatile 关键字,使一个变量在多个线程间可见
    A B线程都用到一个变量, java默认是A线程中保留一份copy,这样如果B线程修改了该变量,则A线程未必知道!
    使用volatile关键字,会让所有线程都会读到变量的修改值!
    不加锁，不使用volatile的情况下 如果A修改了变量，B线程如果不忙的话，比如让B线程休眠，则B线程可能会去内存更新数据，
    在下面的代码中, running是存在于堆内存的t对象中,当线程t1开始运行的时候,会把running值从内存中读到t1线程的工作区,
    在运行过程中直接使用这个copy,并不会每次去读取堆内存,这样,当主线程修改running的值后, t1线程感知不到,所以不会停止运行
    使用volatile,将会强制所有线程都去堆内存中读取running的值/ 当值被修改后，强制所有线程去堆内存中刷新该值
    可以阅读这篇文章进行更深入的理解https://www.cnblogs.com/nexiyi/p/java_memory_model_and_thread.html
    volatile并不能保证多个线程共同修改running变量时所带来的不一致问题,也就是说volatile不能代替synchronized
    wait 释放锁   notify/notifyAll 不释放锁  必须在同步的情况下使用
    Object lock= new Object();
    lock.wait();

5:写一个程序,证明AtomXXx类比synchronized更高效
    比较简单的自增自减的原子性问题可以使用AtomicXXX类来解决
    AtomicInteger count = new AtomicInteger(0);
    用count.incrementAndGet() 替代count++  

6: AtomXXx类可以保证可见性吗?请写一个程序来证明
    AtomicXXX类的一个方法既可以保证可见性，也可以保证原子性

7: 一个程序证明AtomXX类的多个方法并不保证原子性
    AtomicInteger count=new AtomicInteger(0);
    if(count.get()<1000)
        count.incrementAndGet();

8:写一个程序模拟死锁
    synchronized (a) {
                Thread.sleep(1000);
                synchronized (b) {
                    System.out.println("A ok");
                }
            }
    synchronized (b) {
                Thread.sleep(1000);
                synchronized (a) {
                    System.out.println("B ok");
                }
            }
9：写一个固定容量的同步容器，拥有put和get方法，以及getCount方法，
    能够支持2个生产者线程以及10个消费者线程的阻塞调用  使用synchronized 搭配wait和notify/notifyAll来实现   使用ReentrantLock 搭配 await/signalAll实现
    编程技巧：
        wait搭配while使用
        用notifyAll代替notify
    易错点：
        使用while而不是if，if判断后，线程进入wait，被唤醒后不再判断，使用while被唤醒后还会判断
        使用notifyAll而不是notify，notify只唤醒一个线程，可能唤醒的还是生产者，那么程序运行到wait后就走不去了
    public synchronized void put(Integer j) {
        while (getCount() == MAX) {
                this.wait();
            } 
        }
        list.add(j);
        System.out.println(Thread.currentThread().getName()+" 生产了 "+j   );
        count++;
        this.notifyAll();
    }

    public synchronized Integer get() {
        while (getCount() == 0) {
                this.wait();
        }
        Integer integer = (Integer) list.removeFirst();
        System.out.println(Thread.currentThread().getName()+" 消费了 "+integer   );
        count--;
        this.notifyAll();
        return integer;
    }


Lambda 表达式    
    http://blog.oneapm.com/apm-tech/226.html
    https://blog.csdn.net/qq_36951116/article/details/80296967

    将方法作为参数传递，类似于一种匿名函数
    @FunctionalInterface 用这个注解标记
    每个 Lambda 表达式都能隐式地赋值给函数式接口，例如，我们可以通过 Lambda 表达式创建 Runnable 接口的引用。
    Runnable r = () -> System.out.println("hello world");
    当不指明函数式接口时，编译器会自动解释这种转化：
    new Thread(
    () -> System.out.println("hello world")
    ).start();
  
    new Thread(()->System.out.print(1)).start();

    t(new WorkerInterface() {
    public String doSomework(String s) {
        return s;
    }
    });

    t((String s) -> {
        return s;
    });
        
    简写： t(s -> s);

    以下是一些 Lambda 表达式及其函数式接口：
    Consumer<Integer>  c = (int x) -> { System.out.println(x) };
    BiConsumer<Integer, String> b = (Integer x, String y) -> System.out.println(x + " : " + y);
    Predicate<String> p = (String s) -> { s == null };



CountDownLatch
    使用Latch (门问)替代wait notify来进行通知好处是通信方式简单,
    同时也可以指定等待时间使用await和countdown方法替代wait和notify 
    CountDownLatch不涉及锁定, 当count的值为零时当前线程继续运行当不涉及同步,只是涉及线程通信的时候,
    用synchronized + wait/notify就显得太重了
    这时应该考虑countdownlatch/cyclicbarrier/semaphore


ReentrantLock
    reentrantlock用于替代synchronized,可以完成同样功能
    reentrantlock必须要手动释放锁，sys锁定时遇到异常会释放锁，但reentrantlock不会
    使用reentrantlock可以进行"尝试锁定"tryLock,这样无法锁定,或者在指定时间内无法锁定,
    线程可以决定是否继续等待使用ReentrantLock还可以调用lockInterruptibly方法,
    可以对线程interrupt方法做出响应,在一个线程等待锁的过程中,可以被打断
    ReentrantLock还可以指定为公平锁，synchronized为非公平锁

    Lock  lock =new ReentrantLock();
    try{
        lock.lock();
    }finally{
        lock.unlock();
    }

    可以使用tryLock进行尝试锁定，不管锁定与否，方法都将继续执行
    可以根据tryLock的返回值来判断是否锁定
    也可以根据tryLock的时间，由于tryLock(time)抛出异常，所以finally进行unlock的处理
    boolean locked= lock.tryLock();
    if(locked){
        ...
    }
    try{
        lock.tryLock(5,TimeUnit.SECONDS)
    }finally{
        if(locked) lock.unlock();
    }

    interrupt配合lockInterruptibly()中断线程
    Thread t2 = new Thread(() -> {
                try {
                    lock.lockInterruptibly();
                    System.out.println(locked);
                } catch (Exception e) {
                    System.out.println("成功中断");
                } finally {
                    lock.unlock();
                }

            });
            t2.start();
    t2.interrupt() //打断线程2的等待

    公平锁 ：谁等的时间长，谁获得锁
    public static Lock lock =new ReentrantLock(true); //公平锁
    public void run(){
        for(int i=0;i<100;i++){
            lock.lock();
            System.out.println(Thread.currentThread().getName()+" 获得锁");
            lock.unlock();
        }
    }


ThreadLoacl
    ThreadLocal线程局部变量 ThreadLocal是使用空间换时间, synchronized是使用时间换空间
    比如在hibernate中session就存在与ThreadLocal中,避免synchronized的使用


并发容器
    Collections.synchronizedXXX(List/Map)  对线程不安全的容器进行加锁

    ConcurrentQueue
            offer()    代替add() 如果队满，则返回false，不会抛出异常    
            offer("aaa",1,TimeUnit.SECONDS) //按时间段阻塞，插入时最多等待1秒
            poll()     取队列中的元素，如果队列为空，则返回null而不是抛异常
            peek()     看一下，获得队首元素，但不取出 

            put()   //加入，满了则会等待，线程阻塞
            take()  //取出，空了则会等待，线程阻塞

        高并发
        CopyOnWriteList
            读的量特别大，写的量特别小，例如 监听器的配置
        ConcurrentLinkedQueue
        BlockingQueue   阻塞队列   阻塞式的生产者消费者模式
            LinkedBlockingQueue 
                无界队列
            ArrayBlockingQueue  
                有界队列，有固定大小的
            LinkedTransferQueue  
                需要实时处理的队列， transfer() 将生产的东西直接交给消费者，不经过队列，如果没有消费者则阻塞 netty用的比较多，可以用add/offer/put
            SynchromusQueue   
                同步队列 容量为0  不能用add，只能用put ，put调用的还是transfer，本质是一种特殊的TransferQueue，不保留数据
        DelayQueue  
            也是一个无界队列 在队列中待够指定时间才可以被消费   执行定时任务
    
    ConcurrentMap
        不考虑并发
        HashMap
            线程不安全
        TreeMap
            底层通过红黑树实现

        低并发
        HashTable
            对整个容器进行加锁，效率比较低
        Collections.synchronizedXXX(List/Map)
             对线程不安全的容器进行加锁

        高并发
        ConcurrentHashMap
            将对整个容器的锁拆解为多个对容器的分段锁    1.8后没有分段锁，采用CAS？
        ConcurrentSkipListMap
            底层用跳表实现的Map 对插入的数据进行排序





        
        
