
## Java内存模型和线程安全
### 原子性
原子性是指一个操作是不可中断的，即使是在多个线程一起执行的时候，一个操作一旦开始，就不会被其他线程干扰  
i++ 就不是原子操作  
操作1 读i  
操作2 进行i+1  
操作3 将结果写回i  

### 有序性
在并发时，程序的执行可能会出现乱序，原因是cpu为优化代码，会发生指令重排  
![8-有序性.jpg](./images/8-有序性.jpg)
write()方法的代码执行顺序可能会调整，如果先设置为true，那reader()此时读到的数据就有误 
![9-有序性_指令.jpg](./images/9-有序性_指令.jpg)
一行代码可以拆分为多个指令，一条指令可以拆分为多个步骤，可以简化为 IF ID EX MEM WB ，EX：运算，MEM：寄存器从内存读取，WB：写回
每个步骤都会有对应的硬件,如a=b+c 可以在具体的步骤上如下：
- LW  Rb,b  IF ID EX MEM WB
- LW  RC,c     IF ID EX  MEM WB
- ADD Ra,Rb,Rc    IF ID  X   EX MEM WB    //此时上一个指令LW的MEM步骤还没有返回，所有此时X为寄存器
- SW  a,Ra           IF  X   ID EX  MEM WB
标X的地方可以理解为硬件工作的一个空档期，指令重排是改变代码的执行顺序，来填补这些空档期，但是指令重排不能改变程序语义的串行性

![10-有序性_指令重排.jpg](./images/10-有序性_指令重排.jpg)

### 可见性
可见性是指当一个线程修改了某个共享变量的值，其他线程是否能够立即知道这个修改  
有序性问题和可见性问题主要还是来自于程序各个层面的优化，如虚拟机和编译器

虚拟机层面的可见性问题  

![11-虚拟机层面的可见性问题.jpg](images/11-虚拟机层面的可见性问题.jpg)

![12-虚拟机层面的可见性解释.jpg](images/12-虚拟机层面的可见性解释.jpg)

### Happen-Before
- 程序顺序原则：一个线程内保证语义的串行性
- volatile规则：volatile变量的写，先发生于读，这保证了volatile变量的可见性
- 锁规则：解锁必然发生在随后的加锁前
- 传递性：A先于B，B先于C，那么A必先于C
- 线程的start()先于它的每一个动作
- 线程的所有操作先于线程的终结(Thread.join()) 
- 线程的中断先于被中断线程的代码
- 对象的构造函数执行结束先于finalize()方法

### 线程安全的概念
指某个函数在多线程环境中被调用时，能够正确地处理各个线程的局部变量，使程序正确完成
线程安全：多线程访问某个类时，这个类始终都能表现出正确的行为，那么就称这个类是线程安全的

14. 如何实现线程同步
    (1) synchronized 关键字，修饰代码块、方法或静态方法
        同步是一种高开销的操作，因此应该尽量减少同步的内容。通常没有必要同步整个方法，使用synchronized代码块同步关键代码即可。
    (2) ReentrantLock 
        在Java5中新增了java.util.concurrent包来支持同步。ReentrantLock类是可重入、互斥、实现了Lock接口的锁，它与使用synchronized方法和块具有相同的基本行为和语义，并且扩展了其能力。
        ReentrantLock类的常用方法有：
        ReentrantLock()：创建一个ReentrantLock实例；
        lock()：获得锁；
        unlock()：释放锁；
        注：ReentrantLock还有一个可以创建公平锁的构造方法，但由于会大幅降低程序运行效率，不推荐使用。

    (3) ThreadLocal 实现线程同步
        使用ThreadLocal管理变量，则每个使用该变量的线程都获得该变量的一个副本，副本之间相互独立，这样每个线程都可以随意更改自己的变量副本，而不会对其它线程产生影响。
  

## 死锁
产生死锁的4个条件  
- 互斥条件，使用的资源无法共享
- 至少有一个任务必须持有资源且正在等待获取一个被别的任务持有的资源
- 资源不能被其他任务抢占
- 循环等待，A等待B、B等待A

10. 什么是线程死锁?如何避免死锁?
    产生死锁必须具备以下四个条件：
        互斥条件：该资源任意一个时刻只由一个线程占用。
        请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。
        不剥夺条件:线程已获得的资源在末使用完之前不能被其他线程强行剥夺，只有自己使用完毕后才释放资源。
        循环等待条件:若干进程之间形成一种头尾相接的循环等待资源关系。
        破坏互斥条件
        如何避免线程死锁?
        破坏互斥条件        这个条件我们没有办法破坏，因为我们用锁本来就是想让他们互斥的（临界资源需要互斥访问）。
        破坏请求与保持条件  一次性申请所有的资源。(极大的降低资源利用率)
        破坏不剥夺条件      占用部分资源的线程进一步申请其他资源时，如果申请不到，可以主动释放它占有的资源。(自己申请不到，就主动释放自己的资源)
        破坏循环等待条件    靠按序申请资源来预防。按某一顺序申请资源，释放资源则反序释放。破坏循环等待条件。(按顺序访问资源，降低资源利用率)

18. 什么是线程安全，Servlet、变量是线程安全的吗
    线程安全：如果你的代码在多线程下执行和单线程下执行永远都能获得一样的结果，那么你的代码就是线程安全的。
    线程安全问题都是由全局变量及静态变量引起。若每个线程中对全局变量、静态变量只有读操作，而无写操作，一般来说，这是线程安全的；若有多个线程同时执行写操作，一般都需要考虑线程同步，否则就可能影响线程安全。
    Servlet不是线程安全的，Servlet是单实例多线程的，当多个线程同时访问同一个方法，是不能保证共享变量的线程安全的；
    静态变量：线程非安全。static变量被所有实例共享，当声明类变量时，不会生成static变量的副本，而是类的所有实例共享同一个static变量。一旦值被修改，其它对象均对修改可见，因此线程非安全。
    实例变量：单例时线程非安全，非单例时线程安全。实例变量是实例对象私有的，若系统中只存在一个实例对象，则在多线程下，值改变则对其它对象都可见，所以线程非安全的；每个线程都在不同实例对象中执行，则对象之间的修改互不影响，线程安全。
    局部变量：线程安全。定义在方法内部的变量，线程间不共享。
    静态方法：方法中如果没有使用静态变量，就没有线程安全问题；静态方法内部的变量是局部变量。


24. synchronized与ThreadLocal的比较
    （1）ThreadLocal使用场合主要解决多线程中数据因并发产生的不一致问题。ThreadLocal为每个线程中并发访问的数据提供一个副本，通过访问副本来运行业务，这样的结果是耗费了内存，但大大减少了线程同步所带来的性能消耗，也减少了线程并发控制的复杂度；

    （2）ThreadLocal不能使用原子类型，只能使用Object类型。ThreadLocal的使用要比synchronized简单得多；

    （3）ThreadLocal和synchronized都用于解决多线程并发的访问，但是二者有本质区别：synchronized是利用锁的机制，使变量或代码块在某一时刻只能被一个线程访问，而ThreadLocal为每一个线程都提供了变量的副本，使每个线程在某一时间访问到的并不是同一个对象，这样就隔离了多个线程对数据的共享。而synchronized却正好相反，它用于多个线程间通信时能够获取数据共享；

    （4）同步会带来巨大的性能开销，所以同步操作应该是细粒度的（对象中的不同元素使用不同的锁，而不是整个对象一个锁），如果同步使用得当，带来的性能开销是微不足道的，使用同步真正的风险是复杂性和可能破坏资源安全，而不是性能；

    （5）synchronized用于线程间的数据共享，ThreadLocal用于线程间的数据隔离。
    ThreadLocal：数据隔离，适合多个线程需要多次使用同一个对象，并且需要该对象具有相同的初始化值时；
    synchronized：数据同步，当多个线程想访问或修改同一个对象，需要阻塞其它线程从而只允许其中一个线程对其进行访问与修改。

3:线程抛出异常会释放锁吗?
程序在执行过程中,如果出现异常,默认情况锁会被释放,
所以,在并发处理的过程中,有异常要多加小心,不然可能会发生不一致的情况。
如,在一个web app处理过程中, 多个servlet线程共同访问同一个资源,这时如果异常处理不合适
在第一个线程中抛出异常,其他线程就会进入同步代码区,有可能会访问到异常产生时的数据。
解决方法 copyonwrite

4: volatile和synchronized区别?
synchronized 锁的其实是 对象，加在方法上锁的是this对象，加在static方法上，则锁的是class的字节码对象
synchronized 保证原子性和可见性  volatile 保证可见性 
volatile 关键字,使一个变量在多个线程间可见
A B线程都用到一个变量, java默认是A线程中保留一份copy,这样如果B线程修改了该变量,则A线程未必知道!
使用volatile关键字,会让所有线程都会读到变量的修改值!
不加锁，不使用volatile的情况下 如果A修改了变量，B线程如果不忙的话，比如让B线程休眠，则B线程可能会去内存更新数据，
在下面的代码中, running是存在于堆内存的t对象中,当线程t1开始运行的时候,会把running值从内存中读到t1线程的工作区,
在运行过程中直接使用这个copy,并不会每次去读取堆内存,这样,当主线程修改running的值后, t1线程感知不到,所以不会停止运行
使用volatile,将会强制所有线程都去堆内存中读取running的值/ 当值被修改后，强制所有线程去堆内存中刷新该值
可以阅读这篇文章进行更深入的理解https://www.cnblogs.com/nexiyi/p/java_memory_model_and_thread.html
volatile并不能保证多个线程共同修改running变量时所带来的不一致问题,也就是说volatile不能代替synchronized
wait 释放锁   notify/notifyAll 不释放锁  必须在同步的情况下使用
Object lock= new Object();
lock.wait();

ThreadLoacl
ThreadLocal线程局部变量 ThreadLocal是使用空间换时间, synchronized是使用时间换空间
比如在hibernate中session就存在与ThreadLocal中,避免synchronized的使用

思考题
1: A线程正在执行一个对象中的同步方法, B线程是否可以同时执行同一个对象中的非同步方法?    
可以，两者不冲突

2:同上, B线程是否可以同时执行同一个对象中的另一个同步方法?  
一个同步方法可以调用另外一个同步方法，一个线程已经拥有了某个对象的锁，再次申请的时候仍然会得到该对象的锁
也就是说synchronized获得的锁是可重入的， 子类的synchronized方法可以访问父类的synchronoized方法


jps 查看当前的Java进程、
jstack JVM自带的堆栈跟踪工具

**synchronized**  
同步方法只影响锁定同一个锁对象的同步方法。不影响其他线程调用非同步方法，或调用其他锁资源的同步方法。
锁重入：父类可以重入之类构造，子类先拿锁，父类可以重入
线程本来能够运行，但由于等待获取某个锁而阻止它的运行  
指定加锁对象：对指定对象加锁，进入同步代码块前要获得给定对象的锁  
直接作用于实例方法：相当于对当前实例加锁，进入同步代码块前要获得当前实例的锁，锁的是实例对象  
直接作用于静态方法：相当于对当前类加锁，进入同步代码块前要获得当前类的锁，锁的是字节码对象除非封装为包装类，加在方法上，锁的是调用这个方法的实例对象，加在静态方法上，锁的其实是该类对应的字节码对象，而且等待和唤醒必须是同一个锁所以不能对基础类型加锁，

**volatile**
只能保证可见性，不能保证原子性

