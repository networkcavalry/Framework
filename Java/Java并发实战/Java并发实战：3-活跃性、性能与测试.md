# 10.避免活跃性问题

## 10.1 死锁

# 11.性能与可伸缩性

多线程的主要目的还是提高程序的运行性能，使程序更加充分地发挥多核CPU的高性能，提高系统的资源利用率，此外线程还可以使程序在运行现有任务的情况下立即处理新任务，从而提高系统的响应性。

在保证线程安全性的前提下，将性能提升至最大。

## 11.1 对性能的思考

提升性能意味着用最少的资源做更多的事情。对于一个给定的操作，通常会缺乏某种特定的资源，例如CPU的时钟周期、内存、网络带宽、I/O带宽、数据库请求、磁盘空间以及其他资源，当操作性能由于某种特定的资源而受到限制时，我们通常将该操作称为资源密集型的操作，例如：CPU密集型、数据库密集型、I/O密集型。

尽管多线程的目的是提升性能，但是使用多个线程会引入额外的性能开销。如：线程之间的协调（加锁、触发信号、内存同步等），增加的上下文切换，线程的创建和销毁，以及线程的调度等。如果过度地使用线程，那么这些开销将超过性能的提升，使得并行程序比串行程序的性能还要差一些。

### 11.1.1 性能与可伸缩性

应用程序的性能可以采用多个指标来衡量,例如服务时间、延迟时间、吞吐率、效率、可伸缩性以及容量等。其中一些指标(服务时间、等待时间)用于衡量程序的“运行速度”，即某个指定的任务单元需要“多快”才能处理完成。另一些指标(生产量、吞吐量)用于程序的 “处理能力”,即在计算资源一定的情况下,能完成“多少”工作。

可伸领性指的是,当增加计算资源时(例如CPU、内存、存储容量或I/O带宽),程序的吞吐量或者处理能力能相应地增加。

性能的两个方面“多快”和“多少”，是完全独立的，有时候甚至是相互矛盾的，对于服务器而言“多少”（可伸缩性、吞吐量和生产量）比“多快”这个方面更重要一些。

### 11.1.2 评估各种性能权衡因素

“快速排序”算法在大规模数据中的执行效率非常高，但对于小规模的数据来说，“冒泡排序”实际更高效。程序的优化需要根据真实的场景来制定，所以，为了避免不成熟的优化，先让程序正常运行，然后在提高速度。

空间换时间，安全换性能。

## 11.2 Amdahl定律

## 11.3 线程引入的开销

### 11.3.1 上下文切换

### 11.3.2 内存同步

### 11.3.3 阻塞

## 11.4 减少锁竞争