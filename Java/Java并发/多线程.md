## 并行
### 同步(synchronous)和异步(asynchronous)
![1-同步和异步.jpg](./1-同步和异步.jpg)

同步是指代码调用IO操作时，必须等待IO操作完成才返回的调用方式。  
异步是指代码调用IO操作时，不必等IO操作完成就返回的调用方式。  

### 并发(concurrency)和并行(parallelism)
![2-并发和并行.jpg](./2-并发和并行.jpg)

并行是多个线程同一时刻运行，单核CPU在同一时刻无法做到，而多核CPU可以  
并发是多个线程在同一时间段运行，cpu把这个时间段分片给多个线程，由于整个时间段很小，所以我们感觉CPU好像在同时运行这些线程

### 临界区
临界区用来表示一种公共资源或者说是共享数据，可以被多个线程使用，但是每一次，只能一个线程使用它，一旦临界区资源被占用，其他线程想要使用这个资源，就必须等待
![3-临界区.jpg](./3-临界区.jpg)

### 阻塞(Blocking)和非阻塞(Non-Blocking)
阻塞和非阻塞通常用来形容多线程间的相互影响，比如一个线程占用了临界区资源，那么其他所有需要这个资源的线程就必须在这个临界区外进行等待，等待会导致线程挂起。这种情况就是阻塞。此时，如果占用资源的线程一直不愿意释放资源，那么其他所有阻塞在这个临界区上的线程都不能工作  
非阻塞允许多个线程同时进入临界区

### 并发级别
- 阻塞
难进易出，当一个线程进入临界区后，其他线程必须在临界区外等待，进入后完成操作就可以释放资源
- 非阻塞
  - 无障碍  
易进难出，无障碍是一种最弱的非阻塞调度，自由进入临界区，但是在释放资源时，会判断是否发生数据竞争，比如A线程读取数据x，要释放资源时，系统会判断当前的临界区内x值是否发生变化，如果发生变化，则会回滚A线程的操作
  - 无锁  
无锁的前提是无障碍的，而且要保证有一个线程可以胜出  
通过一个实例可以很好的理解，线程A修改了x的值，要释放资源出临界区时，线程B修改了x的值，系统会回滚线程A的操作，线程B要出临界区时，线程C又修改了x的值，这下该回滚B的操作了，线程C要出临界区的时候，之前被回滚的A完成了修改操作，所以C也要被回滚了，此处A打算出临界区，B又来了，这样就形成了一个闭环  
还是A、B、C三个线程修改x值的问题，要想打破之前形成的闭环，就必须要有一个线程先出去，通过竞争的方式每次选出一个线程胜出，胜出的可以释放临界区资源
  - 无等待  
无状态的前提是无锁的，要求所有线程都必须在有限步内完成，而且也是无饥饿的

### 有关并行的2个重要定理
Amdahi定律（阿姆达尔定律）
![4-Amdahl定律.jpg](./4-Amdahl定律.jpg)
Gustafson定律（古斯塔夫森定律）
![5-Gustafson定律.jpg](./5-Gustafson定律.jpg)

## 线程
### 线程状态的转换
![6-线程状态转换图.jpg](./6-线程状态转换图.jpg)

### 线程的基本操作
- 线程启动   
调用线程的start方法，而不是run方法
```java
Thread t1 = new Thread();
t1.start();
```
    直接调用run方法会在当前线程进行方法调用，通过start方法启动，则会创建一个新的线程来执行

- 线程终止   
stop 不推荐使用，stop会立即释放掉该线程所持有的锁  
如果修改了一半就被stop掉，那数据也只会被修改一半

- 线程中断  
interrupt
```java
public void Thread.interrupt()  //中断线程，其实是将线程状态改为中断状态，并不会直接中断线程
public boolean Thread.isInterrupted() //判断是否被中断
public static boolean Thread.interrupted()  //判断是否被中断，并清除当前中断状态

//错误写法  虽然线程设置为中断状态，但内部程序一直在执行
public void run(){
  while(true){
    ...
  }
}
t1.interrupt()

//正确写法   当线程被中断后，会执行完当前的操作后，进入下一轮循环的时候停止
public void run(){
  while(true){
    if(Thread.currentThread().isInterrupted()){
      System.out.println("Interrupted!");
      break;
    }
    ...
  }
}
t1.interrupt()
```

sleep
```java
//当线程在休眠中，被别的线程打断时会抛出InterruptedExecption异常，通过这种方式来提前中断线程的休眠
public static native void sleep(long millis) throws InterruptedExecption
public void run(){
  while(true){
    if(Thread.currentThread().isInterrupted()){
      System.out.println("Interrupted!");
      break;
    }
    try{
      Thread.sleep(10000);
    }catch(InterruptedExecption e){
      //设置中断状态，抛出异常后会清除中断标记位
      Thread.currentThread().ininterrupt();
    }
  }
  }
}
```

- 线程挂起(suspend)和线程继续执行(resume)  
不推荐使用，suspend()不会释放锁，如果resume在suspend前调用则会发生死锁  
jps 查看当前的Java进程、
jstack JVM自带的堆栈跟踪工具

- 等待线程结束(join)和谦让(yeild)  

join  
```java
public final void join() throws InterruptedException
public final synchronized void join(long millis) throws  InterruptedException

//主线程会等待线程t执行完，再进行下一步操作
public static void main(String[]args) throws InterruptedException{
  Thread t=new Thread(A)
  t.start();
  t.join()
  System.out.println("ok")
}
```
```java
join的本质
while(isAlive()){
  wait(0);  //一直等待，直到被唤醒
}
```
线程执行完毕后，系统会调用notifyAll()  
因此不要在Thread实例上使用wait()和notify()  

yeild  
使当前线程放弃当前时间片，重新参与竞争，竞争成功后还是会执行的


### 守护线程
在后台默默的完成一些系统性的服务，比如垃圾回收线程，JIT线程
守护线程是为非守护线程服务的，如果JVM中只剩守护线程，JVM自然会退出
```java
Thread t=new ThreadT();
t.setDaemon(true);
t.start();
```

### 线程优先级
优先级高的线程更容易抢到cpu时间片
```java
public final static int MIN_PRIORITY=1;
public final static int NORM_PRIORITY=5;
public final static int MAX_PRIORITY=10;
```
### Synchronized
- 指定加锁对象：对定对象加锁，进入同步代码块前要获得给定对象的锁
- 直接作用于实例方法：相当于对当前实例加锁，进入同步代码块前要获得当前实例的锁
- 直接作用于静态方法：相当于对当前类加锁，进入同步代码块前要获得当前类的锁，其实锁的是字节码对象

### wait和notify
![7-wait_notify.png](./7-wait_notify.png)

Object.wait()  
线程等待在当前对象上,调用的前提是获得object的锁对象,因为调用wait()方法会释放锁，那么必须先持有锁
```java
synchronized(obj){
  obj.wait();
}
```
Object.notify()/notifyAll()  
通知在这个对象上等待的线程，进行唤醒  
调用的前提也是获得object的锁对象,唤醒在这个锁对象上的一个线程(notifyAll会唤醒全部线程)，被唤醒的线程还不会立即执行，因为要等当前线程执行完释放锁后，才能去抢锁

## Java内存模型和线程安全
### 原子性
原子性是指一个操作是不可中断的，即使是在多个线程一起执行的时候，一个操作一旦开始，就不会被其他线程干扰  
i++ 就不是原子操作  
操作1 读i  
操作2 进行i+1  
操作3 将结果写回i  

### 有序性
在并发时，程序的执行可能会出现乱序，原因是cpu为优化代码，会发生指令重排  
![8-有序性.jpg](./8-有序性.jpg)
write()方法的代码执行顺序可能会调整，如果先设置为true，那reader()此时读到的数据就有误 
![9-有序性_指令.jpg](./9-有序性_指令.jpg)

标X的地方可以理解为硬件工作的一个空档期，指令重排是改变代码的执行顺序，来填补这些空档期，但是指令重排不能改变程序语义的串行性

![10-有序性_指令重排.jpg](./10-有序性_指令重排.jpg)

### 可见性
可见性是指当一个线程修改了某个共享变量的值，其他线程是否能够立即知道这个修改  
有序性问题和可见性问题主要还是来自有程序的优化

虚拟机层面的可见性问题  

![11-虚拟机层面的可见性问题.jpg](./11-虚拟机层面的可见性问题.jpg)

![12-虚拟机层面的可见性解释.jpg](./12-虚拟机层面的可见性解释.jpg)

### Happen-Before
程序顺序原则：一个线程内保证语义的串行性
volatile规则：volatile变量的写，先发生于读，这保证了volatile变量的可见性
锁规则：解锁必然发生在随后的加锁前
传递性：A先于B，B先于C，那么A必先于C
线程的start()先于它的每一个动作
线程的所有操作先于线程的终结(Thread.join()) 
线程的中断先于被中断线程的代码
对象的构造函数执行结束先于finalize()方法

### 线程安全的概念
指某个函数在多线程环境中被调用时，能够正确地处理各个线程的局部变量，使程序正确完成