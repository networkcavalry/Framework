##  1.Java内存结构

**本地方法栈**：存放C的代码

**虚拟机栈**：每个线程都有自己的栈空间，线程中每次方法的执行都会形成一个栈帧，栈帧中保持方法的局部变量。

**永久区（方法区）**：1.8后改称为永久区，perm，class文件的信息，静态变量，字符串常量，常量池

**程序计数器：**程序执行时用到的临时寄存器

**堆**：存放对象的内存区域，也是最大的部分，JVM主要来优化堆内存。

### 1.1 堆内存的构成

![](D:\Study\Framework\JVM\img\1577453722(1).jpg)

**new**（新生代）：25%

eden（伊甸园）：80%

survive1（幸存者区1）：10%

survive2（幸存者区2）：10%

**old**（老年代）：75%

tenured（终身的）：

new出的新对象，很大的话放老年代，其他都先放eden代

### 1.2 堆内存参数调整

### 1.3 用VisualVM观察虚拟机堆信息

## 2.垃圾回收

### 2.1 GC如何确定垃圾

**什么是垃圾？**

不会被使用到的对象就是垃圾， 可能是一个没有引用指向的对象，也可能是两个互相引用的对象，还可能是环形引用的对象。

强引用：

软引用：

弱引用：

虚引用：

**如何确定垃圾？**

引用计数：会用循环引用的问题。

正向可达：从roots对象计算可以到达的对象，到不了的对象可以被认为是垃圾。main方法中创建的对象都是roots对象



### 2.2 垃圾收集算法

#### 2.2.1 Mark-Sweep 标记清除

![](D:\Study\Framework\JVM\img\1577455245(1).jpg)

标记的地方，代表下次创建的对象时可以使用，而不是把该位置保存的值擦除。

缺点：内存碎片化，如果再有大的对象需要被创建，则会进行fullGC，将未被清除的对象压缩复制在一个区域，将碎片化的内存空间整理到一起。

#### 2.2.2 Copying 复制

![](D:\Study\Framework\JVM\img\1577455659(1).jpg)

缺点：浪费内存，4G的话只能2G能用

#### 2.2.3 Mark-Compact 标记压缩

![](D:\Study\Framework\JVM\img\1577456026(1).jpg)

比Copy效率低些。

**JVM采用分代算法**

新生代中eden与survive之间使用Copy算法，存活对象少，占用内存空间也不大，效率也高

老年代采用的是 Mark-Compact 算法，垃圾少





## 3.JVM参数

- `-` 标准参数，所有jvm都应该支持 
- `- X` 非标，每个jvm实现都不同
- `-XX` 不稳定参数，下一个版本可能会取消

JDK1.8默认使用Server模式

## 4.Java对象的分配

对象的存放，会根据对象情况，依次看满足下边从上往下的四个区域。

### 4.1 栈上分配

- 线程私有小对象，随着栈帧的消失而消失，都不用垃圾回收你
- 无逃逸，逃逸的简单理解为，有别的引用可以指向这个对象，这个对象不再完全被方法控制，方法结束，但是这个对象的外部引用还在。
- 支持标量替换
- 无需我们调整

### 4.2 线程本地分配TLAB（Thread Local Allcation Buffer）

- 占用eden，默认1%，是提高对象分配效率的机制
- 多线程的时候不用竞争eden就就可以申请空间，提高效率
- 小对象
- 无需我们调整

### 4.3 老年代

- 大对象，不够大也不放

### 4.4 eden

- 上面都不满足，才会放到eden

Runntime.getRunntime()...()

## 调优Tomcat并使用JMeter进行评测

## 



JVM参数设置
    -Xms  初始堆大小
    -Xmx  最大堆大小
    -Xss  线程的内存空间
    -XX:NewSize=n 设置年轻代大小
    -XX:NewRatio=n 设置年轻代和老年代的比值，如n为3，表示年轻代：年老代=1：3，年轻代占整个年轻代年老代和的1/4
    -XX:SurvivorRatio=n /sə'vaɪvə/ 年轻代中Eden区与两个Survivor区的比值，注意Survivor区有两个，n=3表示Eden:Survivor=3：2，一个Survivor占年轻代的1/5
    -XX:MaxPermSize=n 设置持久代大小
    收集器设置
    -XX:+UseSerialGC    设置串行收集器 
    -XX:+UseParallelCC  设置并行收集器  高吞吐量
    -XX:+UseParalledOldGC   设置并行年老代收集器
    -XX:UseConcMarkSweepGC  设置并发收集器
    垃圾回收统计信息
    -XX:+PrintGC
    -XX:+Printetails
    -XX:+PrintGCTimeStamps
    -Xloggc:filename
    并行收集器设置

调优总结
    年轻代大小选择
        响应时间优先的应用：尽可能设大，年轻代收集发生的频率也是最小的，同时减少到达年老代的对象
JVM堆结构图及分代
    JVM内存分代策略
        Java虚拟机根据对象存活的周期不同，把堆内存划分为几块，一般分为新生代、老年代和永久代（对HotSpot而言）
    为什么要分代？
            堆内存是虚拟机管理的内存中最大的一块，也是垃圾回收最频繁的一块区域，我们程序所有的对象实例都存放在堆内存中。
        给堆内存分代是为了提高对象内存分配和垃圾回收的效率。试想一下，如果堆内存没有区域划分，
        所有的新创建的对象和生命周期很长的对象放在一起，随着程序的执行，堆内存需要频繁进行垃圾收集，
        而每次回收都要遍历所有的对象，会严重影响我们的GC效率。
            有了内存分代，新创建的对象会在新生代中分配内存，经过多次回收仍然存活下来的对象存放在老年代中，
        静态属性、类信息等存放在永久代中，新生代中的对象存活时间短，只需要在新生代区域中频繁进行GC，
        老年代中对象生命周期长，内存回收的频率相对较低，不需要频繁进行回收，永久代中回收效果太差，一般不进行垃圾回收，
        还可以根据不同年代的特点采用合适的垃圾收集算法。分代收集大大提升了收集效率，这些都是内存分代带来的好处。
    新生代
        新生对象优先存放新生代，常规应用进行一次垃圾回收一般会回收70%-95%，回收率很高。
        默认比例   Eden：Survivor0：Survivor1=8:1:1 
        HotSpot 采用复制算法来回收新生代，由于热点探测技术替代之前的虚拟机


java虚拟机内存可以分为三个区域：栈stack、堆heap、方法区method area
    栈stack
        1.jvm为每个线程创建一个栈，，栈中存放该线程执行方法的信息（实际参数、局部变量） 
        2.是描述方法执行的内存模型，每个方法被调用都会创建一个栈帧（存储局部变量、操作数等）
        3.所以栈是私有的，不同线程不能共享
        4.存储特点是“先进后出，后进先出”
        5.系统自动分配的连续内存空间，速度快
    堆heap 
        1.堆用于存储创建好的对象和数组（数组也是对象）
        2.JVM只有一个堆，被所有线程共享
        3.堆是一个不连续的内存空间，分配灵活，速度慢
    方法区
        1.JVM只有一个方法区，被所有线程共享
        2.方法区实际也是堆，只是用于存储类，常量相关的信息
        3.用于存放程序中永远不变或唯一的内容，（类信息[Class对象]，静态变量，字符串常量等）

JVM启动的时候会根据当前线程在内存中创建一个栈，在内存中创建方法区并加载 字节码文件、静态变量、静态方法、字符串常量
然后在静态方法中寻找main方法，开始程序的入口，并为main方法在栈中创建一个栈帧，存储局部变量、操作数、方法出口等

JVM总体结构图
        类  加  载  子  系  统       Java栈
        方法区  Java堆 直接内存      本地方法栈
        垃  圾  回  收  系  统       PC寄存器
        执         行         引          擎
    1) 类加载子系统与方法区:类加载子系统负责从文件系统或者网络中加载Class信息,加载的类信息存放于一块称为方法区的内存空间。
       除了类的信息外,方法区中可能还会存放运行时常量池信息,包括字符串字面量和数字常量(这部分常量信息是class文件中常量池部分的内存映射)
    2) java堆: java堆在虚拟机启动的时候建立,它是java程序最主要的内存工作区域。几乎所有的java对象实例都存放在java堆中。
       堆空间是所有线程共享的,这是一块与java应用密切相关的内存空间。
    3) 直接内存: java的NIO库允许java程序使用直接内存。直接内存是在java堆外的、直接向系统申请的内存空间。通常访问直接内存的速度会优于java堆。
       因此出于性能的考虑,读写频繁的场合可能会考虑使用直接内存。由于直接内存在java堆外,因此它的大小不会直接受限于Xmx指定的最大堆大小,
       但是系统内存是有限的, java堆和直接内存的总和依受限于操作系统能给出的最大内存
    4) 垃圾回收系统:垃圾回收系统是java虚拟机的重要组成部分,垃圾回收器可以对方法区、java堆和直接内存进行回收。其中, java堆是垃圾收集器的工作重点。
       和C/C++不同, java中所有的对象空间释放都是隐式的,也就是说, java中没有类似free()或者delete()这样的还数释放指定的内存区域。
       对于不再使用的垃圾对象,垃圾回收系统会在后台默工作,默默查找、标识并释放垃圾对象，完成java堆、方法区和直接内存的全自动化管理。
    5) java栈:每一个java虚拟机线程都有一个私有的java栈,一个线程的java栈在线程创建的时候被创建, java栈中保存着帧信息, 
       java栈中保存着局部变量、方法参数,同时和java方法的调用、返回密切相关。
    6) 本地方法栈:本地方法栈和java栈非常类似,最大的不同在于java栈用于方法的调用,而本地方法栈则用于本地方法的调用,作为对java虚拟机的重要扩展, 
       java虚拟机允许java直接调用本地方法(通常使用C编写)
    7) PC寄存器: 用来区分java方法还是本地方法。PC寄存器也是每一个线程私有的空间,java虚拟机会为每一个 java线程创建PC寄存器。在任意时刻,一个java线程总是在执行一个方法,
       这个正在被技行的方法称为当前方法。如果当前方法不是本地方法, PC寄存器就会指向当前正在被执行的指令。如果当前方法是本地方法,那么PC寄存器的值就是undefined 
    8) 执行引擎(HotSpot):执行引擎是java虚拟机的最核心组件之一,它负责执行虚拟机的字节码,现代虚拟机为了提高执行效率,会使用即时编译技术将方法编译成机器码后再执行。
        

    Java HotSpot Client VM (-client),为在客户端环境中减少启动时间而优化;
    Java HotSpot Server VM (-server),为在服务器环境中最大程度提高执行速度而设计；

垃圾回收机制
    寻找需要回收的对象，垃圾回收算法
        1.引用计数器
            比较古老的回收算法，原理是此对象增加一个引用，即增加一个计数，减少一个引用，计数器减一，垃圾回收时只收集计数器为0的对象，此算法无法处理循环引用的对象
        2.复制算法
            类似于新生代的处理，将内存空间划为两个相等的区域，每次只使用其中一个区域，垃圾回收时，将正在使用的对象复制到另一区域，复制过去可以进行内存整理，不会出现碎片问题
        3.标记清除法(Mark-Sweep)
            此算法分两阶段，第一阶段从引用根节点开始标记所有被引用的对象，第二阶段，把未被标记的对象清除，此算法需要暂停应用，且会产生内存碎片
        4.标记整理算法

    通用的分代垃圾回收机制：
        根据不同的生命周期将对象划分为 年轻代，年老代，持久代。
        JVM将堆内存划分为 Eden Survivor Tenured/Old空间
        年轻代在 Eden Survivor1 Survivor2   年老代在 Tenured/Old   持久代在方法区
    垃圾回收过程：
        1.新创建的对象，绝大多数都会存储在Eden中
        2.当Eden满了(达到一定比例)不能创建新对象，则触发垃圾回收，通过算法将无用对象清理掉
          然后剩余对象复制到某个Survivor，如Survivor1，同时清空Eden区
        3.当Eden再次满了，会对Survivor1进行清理，然后将剩余的对象存到另一个Survivor中，如Survivor2
          同时将Eden区中不能清空的对象，也复制到Survivor2中，保证Eden和Survivor1,均被清空
        4.重复多次（默认15次）Survivor中没有被清理的对象，则会复制到老年代Tenured/Old
        5.当Tenured/Old满了，则会触发一个一次完整地垃圾回收（FullGC），清理年轻代，老年代，成本较高，会对系统性能产生影响

代码是怎么运行的

JRE:
    Java运行环境(Java Runtime Environment),也就是Java程序运行的必需组件,包含Java虚拟机及Java核心类库等
JDK:
    Java开发工具包(Java Developer's Kit),包含了JRE和一系列开发、诊断工具
JVM:
    1.跨平台性
        C++代码编译成CPU能理解的机器码。
        Java程序通过编译器将代码转换成JVM所能识别的指令序列，也就是Java字节码(因为Java字节码指令的操作码为一个字节)
        JVM可以通过硬件实现，但更常见的是在各个平台(Windows、Linux)提供的软件实现,这样同样的字节码在不同平台上被不同
        的JVM翻译(具体怎么翻译，主要有两种形式)成针对不同平台的机器码来执行，实现Java语言的跨平台性。
    2.托管环境
        助我们处理很多与业务无关但对于程序运行同样重要的事情，比如内存管理和垃圾回收，还有数组越界、动态类型、安全权限等动态检测

JVM如何运行字节码
    1.虚拟机角度
        jvm内存划分
            线程共享：方法区、堆
            线程私有：PC寄存器、Java方法栈、本地方法栈(被native修饰的方法，如arraysCopy())
        加载class文件到jvm，存放在方法区(method area),实际运行时执行方法区内的代码
        每次调用一个java方法，在java方法栈中生成一个栈帧，用来存放局部变量以及字节码操作数，栈帧大小是提前计算好的，而且不要求栈帧在内存中连续分布
        当退出当前执行方法时，不管正常还是异常返回，jvm均会弹出当前线程的当前栈帧
    2.硬件角度
        java字节码无法直接执行，需要jvm将字节码翻译成机器码
        1)解释执行:逐条将字节码翻译成机器码并执行
        2)即时编译(Just-In-Time-compilation,JIT):将一个方法中所有字节码编程成机器码后执行
        前者的优势在于无需等待编译，后者优势在于实际运行速度更快，原因是后者是在编译时拥有程序的运行时信息，并根据信息做出相对优化
        HotSpot默认采用混合模式，先解释执行字节码，然后将反复执行的热点代码，以方法为单位即时编译
        解释执行和即时编译可以同时进行，编译后的机器码在下次调用该方法时启用，替换原本的解释执行

JVM的运行效率
    HotSpot内置了多个即时编译器：C1、C2和Graal(Java 10引入)
    C1：又叫Client编译器，面向的是对启动性能有要求的客户端GUI程序，优化简单，编译时间短
    C2：又叫Server编译器，面向的是对峰值性能有要求的服务器端程序，优化复杂，时间长，但生成代码的执行效率高
    Java 7开始，HotSpot默认采用分层编译的方式，热点方法先由C1编译，而后热点中的热点由C2编译，
    HotSpot的即时编译是放在额外的编译线程中进行的，根据cpu的数量，按1:2的比例配置C1及C2
    



## 2.G1

garbage first

STW：垃圾回收需要的停顿，G1可以使垃圾回收可控。可以使内存不连续

![](D:\study\Framework\JVM\img\1577526717.jpg)

追求响应时间：

-  XX：MaxGCPauseMillis 200  将GC的时间控制在200毫秒
-  可以对STW进行控制

灵活：

- 分Region回收
- 优先回收花费时间少、垃圾比例高的Region

每个Region多大

- 取值 

  ​	1，2，4，8，16，32 单位m

- 手工指定 `-XX：G1HeapRegionSize` 

对象何时进入老年代

1. 超过 `XX:MaxTenuringThreshold` 指定次数（YGC）

   `- Parallel Sacvenge 15`

   `- CMS 6`

   `- G115`

2. 动态年龄

   s1 -> s2 超过50%

   把年龄最大的放入

​	